{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#universal-mcp","title":"Universal MCP","text":""},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Architecture Documentation - System design and flow diagrams for contributors</li> <li>API Reference - Complete API documentation</li> <li>Getting Started - Installation and setup guides</li> </ul> <p>Universal MCP acts as a middleware layer for your API applications, enabling seamless integration with various services through the Model Control Protocol (MCP). It simplifies credential management, authorization, dynamic app enablement, and provides a robust framework for building and managing AI-powered tools.</p>"},{"location":"#features","title":"\ud83c\udf1f Features","text":"<ul> <li>MCP (Model Control Protocol) Integration: Seamlessly works with MCP server architecture for standardized agent-tool communication.</li> <li>Simplified API Integration: Connect to services like GitHub, Google Calendar, Gmail, Reddit, Tavily, and more with minimal code. See AgentR for a list of available applications.</li> <li>Managed Authentication: Built-in support for API keys and OAuth-based authentication flows, often managed via the AgentR platform.</li> <li>Extensible Architecture: Easily build and add new app integrations with minimal boilerplate using provided base classes and generation tools.</li> <li>Credential Management: Flexible and secure storage options for API credentials (memory, environment variables, system keyring).</li> <li>Comprehensive Tool Management: Robust tool registration, Pydantic-based validation, automatic docstring parsing, and execution capabilities. Supports conversion between MCP, LangChain, and OpenAI tool formats.</li> <li>Multiple Server Types: Configurations for local development, AgentR-connected dynamic app loading, and single-application servers.</li> <li>Playground Environment: Includes an interactive Streamlit-based playground for testing agents and tools.</li> </ul>"},{"location":"#installation","title":"\ud83d\udd27 Installation","text":"<p>Install Universal MCP using pip:</p> <pre><code>pip install universal-mcp\n</code></pre>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>Important Prerequisite: AgentR API Key (If Using AgentR Integration)</p> <p>If you plan to use integrations with <code>type: \"agentr\"</code> (for services like GitHub, Gmail, Notion via the AgentR platform), or if you run the MCP server itself with <code>type: \"agentr\"</code>, you first need an AgentR API key:</p> <ol> <li>Visit https://agentr.dev to create an account and generate an API key from your dashboard.</li> <li>Set it as an environment variable before running the MCP server:     <pre><code>export AGENTR_API_KEY=\"your_api_key_here\"\n</code></pre></li> </ol> <p>1. Create a Configuration File (e.g., <code>config.json</code>)</p> <p>This file defines the server settings, credential stores, and the applications to load with their respective integrations.</p> <pre><code>{\n  \"name\": \"My Local MCP Server\",\n  \"description\": \"A server for testing applications locally\",\n  \"type\": \"local\", // \"local\" or \"agentr\"\n  \"transport\": \"sse\", // \"sse\", \"stdio\", or \"http\"\n  \"port\": 8005, // Relevant for \"sse\" or \"http\"\n  \"store\": {\n    // Default store for integrations\n    \"name\": \"my_mcp_store\",\n    \"type\": \"keyring\" // \"keyring\", \"environment\", or \"memory\"\n  },\n  \"apps\": [\n    {\n      \"name\": \"zenquotes\", // App slug (e.g., from agentr.dev)\n      \"integration\": null // No authentication needed for this app\n    },\n    {\n      \"name\": \"tavily\",\n      \"integration\": {\n        \"name\": \"TAVILY_API_KEY\", // Unique name for this credential if type is \"api_key\"\n        \"type\": \"api_key\",\n        \"store\": {\n          // Override default store for this specific app\n          \"type\": \"environment\" // Looks for TAVILY_API_KEY env var\n        }\n      }\n    },\n    {\n      \"name\": \"github\",\n      \"integration\": {\n        \"name\": \"github\", // Matches the service name in AgentR\n        \"type\": \"agentr\" // Uses AgentR platform for auth/creds\n      }\n    }\n  ]\n}\n</code></pre> <p>Notes on <code>config.json</code>:</p> <ul> <li><code>type: \"local\"</code>: Runs applications defined directly in the config's <code>apps</code> list.</li> <li><code>type: \"agentr\"</code>: Connects to the AgentR platform to dynamically load user-enabled apps (ignores the <code>apps</code> list in the config) and handle credentials. Requires <code>AGENTR_API_KEY</code> environment variable.</li> <li><code>store</code>: Defines credential storage.</li> <li><code>environment</code>: Looks for an environment variable named <code>&lt;INTEGRATION_NAME_UPPERCASE&gt;</code> (e.g., <code>TAVILY_API_KEY</code> for the example above).</li> <li><code>keyring</code>: Uses the system's secure credential storage.</li> <li><code>memory</code>: Transient storage, lost when the server stops.</li> <li><code>integration</code>: Configures authentication for each app.</li> <li><code>type: \"agentr\"</code>: Uses the AgentR platform for OAuth/credential management.</li> <li><code>type: \"api_key\"</code>: Uses the specified <code>store</code> to retrieve the key.</li> </ul> <p>2. Run the Server via CLI</p> <p>Ensure any required environment variables (like <code>TAVILY_API_KEY</code> for the Tavily example, or <code>AGENTR_API_KEY</code> if using <code>\"agentr\"</code> type server/integrations) are set.</p> <pre><code>universal_mcp run -c config.json\n</code></pre> <p>The server will start, load the configured applications (or connect to AgentR if <code>type: \"agentr\"</code>), and listen for connections based on the <code>transport</code> type.</p>"},{"location":"#using-the-playground","title":"\ud83d\udee0\ufe0f Using the Playground","text":"<p>The <code>playground</code> directory provides a runnable Streamlit application for interacting with agents that can use tools from an MCP server.</p> <p>Prerequisites:</p> <ul> <li><code>local_config.json</code>: This file must exist in the project root directory (the same directory as this <code>README.md</code>). It configures the local MCP server that the playground's agent can connect to if you choose to run one. For an example, see the <code>local_config.json</code> structure in the Playground README.</li> <li>Dependencies: Install playground-specific dependencies. If you have the project cloned, you might install them via:   <pre><code>pip install -e .[playground]\n# or manually install fastapi, streamlit, uvicorn, langchain-openai, etc.\n</code></pre></li> </ul> <p>Running the Playground:</p> <p>The easiest way is to use the automated startup script from the project root directory:</p> <pre><code>python playground\n</code></pre> <p>This script will:</p> <ol> <li>Optionally start a local MCP server (based on your <code>local_config.json</code>) if you confirm.</li> <li>Launch the Streamlit application.</li> </ol> <p>For more detailed setup, manual startup instructions, and an explanation of the <code>local_config.json</code> for the playground, please refer to the Playground README.</p>"},{"location":"#available-applications","title":"\ud83e\udde9 Available Applications","text":"<p>Universal MCP can integrate with a wide variety of applications. For a list of publicly available applications and their slugs (e.g., \"github\", \"google-calendar\"), please visit AgentR Applications. Applications are typically installed dynamically by Universal MCP from their respective repositories when first referenced by slug.</p> <p>Authentication Type Notes:</p> <ul> <li>OAuth (via AgentR): Usually requires configuring the app's integration with <code>type: \"agentr\"</code> in your <code>ServerConfig</code>. This leverages the AgentR platform for the OAuth flow and requires the <code>AGENTR_API_KEY</code> to be set.</li> <li>API Key (via Integration): Requires configuring <code>type: \"api_key\"</code> for the app's integration in your <code>ServerConfig</code>, along with a <code>store</code> (like <code>environment</code> or <code>keyring</code>) to specify where the API key is located.</li> </ul>"},{"location":"#integration-types","title":"\ud83d\udd10 Integration Types","text":"<p>Universal MCP supports different ways to handle authentication for applications:</p>"},{"location":"#1-api-key-integration-type-api_key","title":"1. API Key Integration (<code>type: \"api_key\"</code>)","text":"<p>For services that authenticate via simple API keys.</p> <pre><code>// In your ServerConfig apps array:\n{\n  \"name\": \"tavily\",\n  \"integration\": {\n    \"name\": \"TAVILY_API_KEY\", // Used by the store (e.g., as env var name)\n    \"type\": \"api_key\",\n    \"store\": {\n      \"type\": \"environment\" // Or \"keyring\", \"memory\"\n    }\n  }\n}\n</code></pre>"},{"location":"#2-agentr-integration-type-agentr","title":"2. AgentR Integration (<code>type: \"agentr\"</code>)","text":"<p>Recommended for services integrated with the AgentR platform, which typically handles OAuth flows or centrally managed credentials. Requires the <code>AGENTR_API_KEY</code> environment variable to be set for the MCP server process.</p> <pre><code>// In your ServerConfig apps array:\n{\n  \"name\": \"github\",\n  \"integration\": {\n    \"name\": \"github\", // Matches the service name configured in AgentR\n    \"type\": \"agentr\"\n  }\n}\n</code></pre> <p>When an action requiring authorization is called, the <code>AgentRIntegration</code> will prompt the user (via the MCP client) to visit a URL to complete the OAuth flow managed by AgentR. This is also the default integration type for apps if the main server config is <code>type: \"agentr\"</code>.</p>"},{"location":"#3-direct-oauth-integration-type-oauth","title":"3. Direct OAuth Integration (<code>type: \"oauth\"</code>)","text":"<p>While <code>AgentRIntegration</code> is generally preferred for OAuth, a direct <code>OAuthIntegration</code> class exists. However, it requires manual configuration of client IDs, secrets, and callback handling, which is more complex to set up outside the AgentR platform.</p>"},{"location":"#cli-usage","title":"\ud83e\udd16 CLI Usage","text":"<p>Universal MCP includes a powerful command-line interface:</p> <pre><code># Run the MCP server using a configuration file\nuniversal_mcp run -c config.json\n\n# Initialize a new MCP application project structure\nuniversal_mcp init --app-name my-cool-app --o ./my-apps --integration-type api_key\n\n# Generate API client code and application structure from an OpenAPI schema\nuniversal_mcp generate -s &lt;path_to_schema.json_or_yaml&gt; -o &lt;path/to/app_output_directory&gt; --c CustomAppClassName\n# Example: universal_mcp generate -s notion_api.yaml -o ./custom_apps/notion --c MyNotionApp\n\n# Preprocess an OpenAPI schema using an LLM to fill/enhance descriptions\nuniversal_mcp preprocess -s &lt;path_to_input_schema.json_or_yaml&gt; -o &lt;path_to_processed_schema.json_or_yaml&gt;\n\n# Generate Google-style docstrings for functions in a Python file using an LLM\nuniversal_mcp docgen &lt;path/to/app_file.py&gt;\n\n# Generate a README.md for a generated application file\nuniversal_mcp readme &lt;path/to/app_file.py&gt;\n\n# Install MCP configuration for supported desktop apps (e.g., Claude, Cursor)\n# Requires an AgentR API key for configuration.\nuniversal_mcp install claude\nuniversal_mcp install cursor\n\n# Check installed version (standard typer command)\nuniversal_mcp --version\n</code></pre>"},{"location":"#requirements","title":"\ud83d\udccb Requirements","text":"<ul> <li>Python 3.10+</li> <li>Key Dependencies (installed automatically via pip, see <code>pyproject.toml</code> for full list):</li> <li><code>mcp-server</code></li> <li><code>loguru</code></li> <li><code>typer</code></li> <li><code>httpx</code></li> <li><code>pydantic</code></li> <li><code>pyyaml</code></li> <li><code>keyring</code> (for <code>KeyringStore</code>)</li> <li><code>litellm</code> (for <code>docgen</code> and <code>preprocess</code> commands)</li> <li><code>uv</code> (used internally for dynamic package installation)</li> </ul>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<p>For more detailed information about specific components:</p> <ul> <li>Applications Framework</li> <li>Tool Management</li> <li>Server Implementations</li> <li>Credential Stores</li> <li>Integration &amp; Authentication</li> <li>Playground Usage</li> </ul>"},{"location":"#license","title":"\ud83d\udcdd License","text":"<p>This project is licensed under the MIT License. See the LICENSE file for details.</p>"},{"location":"applications/","title":"Applications","text":""},{"location":"applications/#universal-mcp-applications-module","title":"Universal MCP Applications Module","text":"<p>This module provides the core functionality for managing and integrating applications within the Universal MCP system. It offers a flexible framework for creating, managing, and interacting with various types of applications through a unified interface.</p>"},{"location":"applications/#overview","title":"Overview","text":"<p>The applications module provides three main base classes for building application integrations:</p> <ol> <li><code>BaseApplication</code>: The abstract base class that defines the common interface for all applications</li> <li><code>APIApplication</code>: A concrete implementation for applications that communicate via HTTP APIs</li> <li><code>GraphQLApplication</code>: A specialized implementation for applications that use GraphQL APIs</li> </ol>"},{"location":"applications/#key-features","title":"Key Features","text":"<ul> <li>Dynamic Application Loading: Applications can be loaded dynamically from external packages</li> <li>Unified Credential Management: Centralized handling of application credentials</li> <li>HTTP API Support: Built-in support for RESTful API interactions</li> <li>GraphQL Support: Specialized support for GraphQL-based applications</li> <li>Automatic Package Installation: Automatic installation of application packages from GitHub</li> </ul>"},{"location":"applications/#base-classes","title":"Base Classes","text":""},{"location":"applications/#baseapplication","title":"BaseApplication","text":"<p>The foundation class for all applications, providing: - Basic initialization - Credential management - Tool listing interface</p>"},{"location":"applications/#apiapplication","title":"APIApplication","text":"<p>Extends BaseApplication to provide: - HTTP client management - Authentication handling - Common HTTP methods (GET, POST, PUT, DELETE, PATCH) - Request/response handling</p>"},{"location":"applications/#graphqlapplication","title":"GraphQLApplication","text":"<p>Specialized for GraphQL-based applications, offering: - GraphQL client management - Query and mutation execution - Authentication handling</p>"},{"location":"applications/#usage","title":"Usage","text":""},{"location":"applications/#creating-a-new-application","title":"Creating a New Application","text":"<ol> <li>Create a new package following the naming convention: <code>universal_mcp_&lt;app_name&gt;</code></li> <li>Implement your application class inheriting from one of the base classes</li> <li>Name your class following the convention: <code>&lt;AppName&gt;App</code></li> </ol> <p>Example: </p><pre><code>from universal_mcp.applications import APIApplication\n\nclass MyApp(APIApplication):\n    def __init__(self, name: str, integration=None, **kwargs):\n        super().__init__(name, integration, **kwargs)\n        self.base_url = \"https://api.example.com\"\n\n    def list_tools(self):\n        return [self.my_tool]\n\n    def my_tool(self):\n        # Implementation here\n        pass\n</code></pre><p></p>"},{"location":"applications/#loading-an-application","title":"Loading an Application","text":"<pre><code>from universal_mcp.applications import app_from_config\nfrom universal_mcp.config import AppConfig\n\napp_config_pkg = AppConfig(name=\"my-app\")\nMyAppFromPackage = app_from_config(app_config_pkg)\napp_pkg_instance = MyAppFromPackage()\n</code></pre>"},{"location":"applications/#authentication","title":"Authentication","text":"<p>The module supports various authentication methods: - API Keys - Access Tokens - Custom Headers - Bearer Tokens</p> <p>Credentials are managed through the integration system and can be accessed via the <code>credentials</code> property.</p>"},{"location":"applications/#error-handling","title":"Error Handling","text":"<p>The module includes comprehensive error handling for: - Package installation failures - Import errors - API request failures - Authentication issues</p>"},{"location":"applications/#logging","title":"Logging","text":"<p>All operations are logged using the <code>loguru</code> logger, providing detailed information about: - Application initialization - API requests - Authentication attempts - Package installation - Error conditions</p>"},{"location":"applications/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8+</li> <li>httpx</li> <li>gql</li> <li>loguru</li> <li>uv (for package installation)</li> </ul>"},{"location":"applications/#contributing","title":"Contributing","text":"<p>To contribute a new application: 1. Create a new package following the naming conventions 2. Implement the application class 3. Add proper error handling and logging 4. Include comprehensive documentation 5. Submit a pull request to the Universal MCP repository</p>"},{"location":"integrations/","title":"Integrations","text":""},{"location":"integrations/#integrations","title":"Integrations","text":"<p>This package provides integration classes for handling authentication and authorization with external services.</p>"},{"location":"integrations/#overview","title":"Overview","text":"<p>An Integration defines how an application authenticates and authorizes with a service provider. The base <code>Integration</code> class provides an interface that all integrations must implement.</p>"},{"location":"integrations/#supported-integrations","title":"Supported Integrations","text":""},{"location":"integrations/#agentr-integration","title":"AgentR Integration","text":"<p>The <code>AgentRIntegration</code> class handles OAuth-based authentication flow with the AgentR API. It requires an API key which can be obtained from agentr.dev.</p>"},{"location":"integrations/#api-key-integration","title":"API Key Integration","text":"<p>The <code>ApiKeyIntegration</code> class provides a simple API key based authentication mechanism. API keys are configured via environment variables.</p>"},{"location":"integrations/#usage","title":"Usage","text":"<p>Each integration implements three key methods:</p> <ul> <li><code>authorize()</code> - Initiates the authorization flow</li> <li><code>get_credentials()</code> - Retrieves stored credentials</li> <li><code>set_credentials()</code> - Stores new credentials</li> </ul> <p>See the individual integration classes for specific usage details.</p>"},{"location":"playground/","title":"Playground","text":""},{"location":"playground/#universal-mcp-playground","title":"Universal MCP Playground","text":"<p>The Playground provides an interactive environment to test and demonstrate the capabilities of agents built with LangGraph that utilize tools exposed via the Universal MCP (Model Control Protocol). It features a Streamlit-based chat interface allowing users to interact with an AI agent that can leverage tools from a connected MCP server.</p>"},{"location":"playground/#prerequisites","title":"\ud83d\udccb Prerequisites","text":"<p>Before running the playground, ensure you have the following:</p> <ol> <li>Python Environment: Python 3.11+ is recommended.</li> <li> <p>Dependencies: Install the necessary dependencies. If you have the project cloned, you can often install them using:</p> <pre><code>pip install -e .[playground]\n</code></pre> <p>Alternatively, manually install <code>streamlit</code>, <code>langchain-openai</code>, <code>langgraph</code>, <code>langchain-mcp-adapters</code>, <code>loguru</code>, <code>pydantic</code>, etc.</p> </li> <li> <p>LLM API Access (Azure OpenAI by default):     The default agent in <code>playground/agents/react.py</code> uses <code>AzureChatOpenAI</code>. You'll need to set the following environment variables:</p> <ul> <li><code>AZURE_OPENAI_API_KEY</code>: Your Azure OpenAI API key.</li> <li><code>AZURE_OPENAI_ENDPOINT</code>: Your Azure OpenAI endpoint URL.   If you wish to use a different LLM, you'll need to modify <code>playground/agents/react.py</code>.</li> </ul> </li> <li> <p>AgentR API Key (for Auto Agent):     If you want to use the Auto Agent, you'll need to set the following environment variable:</p> <ul> <li><code>AUTO_AGENT_API_KEY</code>: Your AgentR API key (get it from agentr.dev)</li> </ul> </li> <li> <p><code>local_config.json</code> in Project Root:     This file is crucial. It configures the local Universal MCP server that the playground's agent will connect to for tools. This file must be placed in the root directory of the <code>universal-mcp</code> project (i.e., one level above the <code>src</code> directory).</p> <p>The agent in <code>playground/agents/react.py</code> expects to connect to an MCP server at <code>http://localhost:8005</code> using Server-Sent Events (SSE). Therefore, your <code>local_config.json</code> should reflect this:</p> <p>Example <code>local_config.json</code> (place in project root):</p> <pre><code>{\n  \"name\": \"Playground Local MCP Server\",\n  \"description\": \"MCP server for playground agent tools\",\n  \"type\": \"local\",\n  \"transport\": \"sse\", // Must be \"sse\" for the playground agent\n  \"port\": 8005, // Must be 8005 for the playground agent\n  \"apps\": [\n    {\n      \"name\": \"zenquotes\" // Example: Exposes the zenquotes app and its tools\n    },\n    {\n      \"name\": \"tavily\", // Example: Exposes Tavily search\n      \"integration\": {\n        \"name\": \"TAVILY_API_KEY\", // Credential name\n        \"type\": \"api_key\",\n        \"store\": {\n          \"type\": \"environment\" // Expects TAVILY_API_KEY env var\n        }\n      }\n    }\n    // Add other apps you want the agent to access\n  ]\n}\n</code></pre> <ul> <li>Ensure the <code>transport</code> is <code>\"sse\"</code> and <code>port</code> is <code>8005</code>.</li> <li>Add any applications (tools) you want the agent to be able to use in the <code>apps</code> array. Ensure any necessary API keys for these tools are set as environment variables if their integration is configured to use <code>type: \"environment\"</code>.</li> </ul> </li> </ol>"},{"location":"playground/#agent-types","title":"\ud83e\udd16 Agent Types","text":"<p>The playground supports two different agent types:</p>"},{"location":"playground/#react-agent-default","title":"React Agent (Default)","text":"<p>The traditional MCP-based agent that connects to MCP servers and uses tools via the Model Control Protocol. This agent works with the local MCP server configuration.</p>"},{"location":"playground/#auto-agent","title":"Auto Agent","text":"<p>An intelligent agent that can: - Decompose complex tasks into individual steps - Automatically search for and select relevant apps for each task - Choose appropriate actions from those apps - Execute tasks in sequence with context passing between steps</p> <p>To use the Auto Agent, you'll need to set the <code>AUTO_AGENT_API_KEY</code> environment variable.</p>"},{"location":"playground/#running-the-playground","title":"\u25b6\ufe0f Running the Playground","text":""},{"location":"playground/#automated-startup-recommended","title":"Automated Startup (Recommended)","text":"<p>The easiest way to start all necessary services is using the provided Python startup script. Execute this command from the root directory of the <code>universal-mcp</code> project:</p> <pre><code>python playground\n</code></pre> <p>This script will:</p> <ol> <li>Prompt you if you want to run a local MCP server (using <code>local_config.json</code>). If you say yes, it starts the MCP server.</li> <li>Launch the Streamlit application.</li> </ol> <p>Your default web browser should open to the Streamlit app.</p>"},{"location":"playground/#manual-startup-alternative","title":"Manual Startup (Alternative)","text":"<p>If you prefer, or if the automated script doesn't suit your needs, you can start the components manually. Run each command from the project root directory in a separate terminal window:</p> <ol> <li> <p>Terminal 1: Start the Universal MCP Server (Ensures the agent has tools to connect to. Uses <code>local_config.json</code> from the project root.)</p> <pre><code>universal_mcp run -c local_config.json\n</code></pre> <p>Wait for the server to indicate it's running (e.g., \"MCP SSE Server running on http://localhost:8005\").</p> </li> <li> <p>Terminal 2: Start the Streamlit Application </p><pre><code>python -m streamlit run playground/streamlit.py\n</code></pre> This will typically open the Streamlit app in your default web browser.<p></p> </li> </ol>"},{"location":"playground/#x-stopping-the-services","title":"X Stopping the Services","text":"<ul> <li> <p>Automated Startup: Press <code>Ctrl + C</code> in the terminal where you ran <code>python playground</code>. This should terminate both the Streamlit app and the MCP server (if started by the script).</p> </li> <li> <p>Manual Startup: Go to each terminal window where you started a service (MCP server, Streamlit app) and press <code>Ctrl + C</code>.</p> </li> </ul>"},{"location":"servers/","title":"Servers","text":""},{"location":"servers/#servers","title":"Servers","text":"<p>This package provides server implementations for hosting and managing MCP (Model Control Protocol) applications.</p>"},{"location":"servers/#overview","title":"Overview","text":"<p>The server implementations provide different ways to host and expose MCP applications and their tools. The base <code>BaseServer</code> class provides common functionality that all server implementations inherit.</p>"},{"location":"servers/#supported-server-types","title":"Supported Server Types","text":""},{"location":"servers/#local-server","title":"Local Server","text":"<p>The <code>LocalServer</code> class provides a local development server implementation that: - Loads applications from local configuration - Manages a local store for data persistence - Supports integration with external services - Exposes application tools through the MCP protocol</p>"},{"location":"servers/#agentr-server","title":"AgentR Server","text":"<p>The <code>AgentRServer</code> class provides a server implementation that: - Connects to the AgentR API - Dynamically fetches and loads available applications - Manages AgentR-specific integrations - Requires an API key for authentication</p>"},{"location":"servers/#single-mcp-server","title":"Single MCP Server","text":"<p>The <code>SingleMCPServer</code> class provides a minimal server implementation that: - Hosts a single application instance - Ideal for development and testing - Does not manage integrations or stores internally - Exposes only the tools from the provided application</p>"},{"location":"servers/#core-features","title":"Core Features","text":"<p>All server implementations provide:</p> <ul> <li>Tool management and registration</li> <li>Application loading and configuration</li> <li>Error handling and logging</li> <li>MCP protocol compliance</li> <li>Integration support</li> </ul>"},{"location":"servers/#usage","title":"Usage","text":"<p>Each server implementation can be initialized with a <code>ServerConfig</code> object that specifies: - Server name and description - Port configuration - Application configurations - Store configuration (where applicable)</p> <p>Example: </p><pre><code>from universal_mcp.servers import LocalServer\nfrom universal_mcp.config import ServerConfig\n\nconfig = ServerConfig(\n    name=\"My Local Server\",\n    description=\"Development server for testing applications\",\n    port=8000,\n    # ... additional configuration\n)\n\nserver = LocalServer(config)\n</code></pre><p></p>"},{"location":"servers/#tool-management","title":"Tool Management","text":"<p>Servers provide methods for: - Adding individual tools - Listing available tools - Calling tools with proper error handling - Formatting tool results</p>"},{"location":"servers/#error-handling","title":"Error Handling","text":"<p>All servers implement comprehensive error handling for: - Tool execution failures - Application loading errors - Integration setup issues - API communication problems</p>"},{"location":"stores/","title":"Stores","text":""},{"location":"stores/#universal-mcp-stores","title":"Universal MCP Stores","text":"<p>The stores module provides a flexible and secure way to manage credentials and sensitive data across different storage backends. It implements a common interface for storing, retrieving, and deleting sensitive information.</p>"},{"location":"stores/#features","title":"Features","text":"<ul> <li>Abstract base class defining a consistent interface for credential stores</li> <li>Multiple storage backend implementations:</li> <li>In-memory store (temporary storage)</li> <li>Environment variable store</li> <li>System keyring store (secure credential storage)</li> <li>Exception handling for common error cases</li> <li>Type hints and comprehensive documentation</li> </ul>"},{"location":"stores/#available-store-implementations","title":"Available Store Implementations","text":""},{"location":"stores/#memorystore","title":"MemoryStore","text":"<p>A simple in-memory store that persists data only for the duration of program execution. Useful for testing or temporary storage.</p> <pre><code>from universal_mcp.stores import MemoryStore\n\nstore = MemoryStore()\nstore.set(\"api_key\", \"secret123\")\nvalue = store.get(\"api_key\")  # Returns \"secret123\"\n</code></pre>"},{"location":"stores/#environmentstore","title":"EnvironmentStore","text":"<p>Uses environment variables to store and retrieve credentials. Useful for containerized environments or CI/CD pipelines.</p> <pre><code>from universal_mcp.stores import EnvironmentStore\n\nstore = EnvironmentStore()\nstore.set(\"API_KEY\", \"secret123\")\nvalue = store.get(\"API_KEY\")  # Returns \"secret123\"\n</code></pre>"},{"location":"stores/#keyringstore","title":"KeyringStore","text":"<p>Leverages the system's secure credential storage facility. Provides the most secure option for storing sensitive data.</p> <pre><code>from universal_mcp.stores import KeyringStore\n\nstore = KeyringStore(app_name=\"my_app\")\nstore.set(\"api_key\", \"secret123\")\nvalue = store.get(\"api_key\")  # Returns \"secret123\"\n</code></pre>"},{"location":"stores/#error-handling","title":"Error Handling","text":"<p>The module provides specific exception types for handling errors:</p> <ul> <li><code>StoreError</code>: Base exception for all store-related errors</li> <li><code>KeyNotFoundError</code>: Raised when a requested key is not found in the store</li> </ul>"},{"location":"stores/#best-practices","title":"Best Practices","text":"<ol> <li>Use <code>KeyringStore</code> for production environments where security is a priority</li> <li>Use <code>EnvironmentStore</code> for containerized or cloud environments</li> <li>Use <code>MemoryStore</code> for testing or temporary storage only</li> <li>Always handle <code>StoreError</code> and <code>KeyNotFoundError</code> exceptions appropriately</li> </ol>"},{"location":"stores/#dependencies","title":"Dependencies","text":"<ul> <li><code>keyring</code>: Required for the KeyringStore implementation</li> <li><code>loguru</code>: Used for logging operations in the KeyringStore</li> </ul>"},{"location":"stores/#contributing","title":"Contributing","text":"<p>New store implementations should inherit from <code>BaseStore</code> and implement all required abstract methods: - <code>get(key: str) -&gt; Any</code> - <code>set(key: str, value: str) -&gt; None</code> - <code>delete(key: str) -&gt; None</code></p>"},{"location":"tools_framework/","title":"Tools Framework","text":""},{"location":"tools_framework/#universal-mcp-tools","title":"Universal MCP Tools","text":"<p>This directory contains the core tooling infrastructure for Universal MCP, providing a flexible and extensible framework for defining, managing, and converting tools across different formats.</p>"},{"location":"tools_framework/#components","title":"Components","text":""},{"location":"tools_framework/#toolspy","title":"<code>tools.py</code>","text":"<p>The main module containing the core tool management functionality:</p> <ul> <li><code>Tool</code> class: Represents a tool with metadata, validation, and execution capabilities</li> <li><code>ToolManager</code> class: Manages tool registration, lookup, and execution</li> <li>Conversion utilities for different tool formats (OpenAI, LangChain, MCP)</li> </ul>"},{"location":"tools_framework/#adapterspy","title":"<code>adapters.py</code>","text":"<p>Contains adapters for converting tools between different formats: - <code>convert_tool_to_mcp_tool</code>: Converts a tool to MCP format - <code>convert_tool_to_langchain_tool</code>: Converts a tool to LangChain format</p>"},{"location":"tools_framework/#func_metadatapy","title":"<code>func_metadata.py</code>","text":"<p>Provides function metadata and argument validation: - <code>FuncMetadata</code> class: Handles function signature analysis and argument validation - <code>ArgModelBase</code> class: Base model for function arguments - Utilities for parsing and validating function signatures</p>"},{"location":"tools_framework/#usage","title":"Usage","text":""},{"location":"tools_framework/#creating-a-tool","title":"Creating a Tool","text":"<pre><code>from universal_mcp.tools import Tool\n\ndef my_tool(param1: str, param2: int) -&gt; str:\n    \"\"\"A simple tool that does something.\n\n    Args:\n        param1: Description of param1\n        param2: Description of param2\n\n    Returns:\n        Description of return value\n    \"\"\"\n    return f\"Result: {param1} {param2}\"\n\ntool = Tool.from_function(my_tool)\n</code></pre>"},{"location":"tools_framework/#managing-tools","title":"Managing Tools","text":"<pre><code>from universal_mcp.tools import ToolManager\n\nmanager = ToolManager()\nmanager.add_tool(my_tool)\n\n# Get a tool by name\ntool = manager.get_tool(\"my_tool\")\n\n# List all tools in a specific format\ntools = manager.list_tools(format=\"openai\")  # or \"langchain\" or \"mcp\"\n</code></pre>"},{"location":"tools_framework/#converting-tools","title":"Converting Tools","text":"<pre><code>from universal_mcp.tools import convert_tool_to_langchain_tool\n\nlangchain_tool = convert_tool_to_langchain_tool(tool)\n</code></pre>"},{"location":"tools_framework/#features","title":"Features","text":"<ul> <li>Automatic docstring parsing for tool metadata</li> <li>Type validation using Pydantic</li> <li>Support for both sync and async tools</li> <li>JSON schema generation for tool parameters</li> <li>Error handling and analytics tracking</li> <li>Tag-based tool organization</li> <li>Multiple format support (OpenAI, LangChain, MCP)</li> </ul>"},{"location":"tools_framework/#best-practices","title":"Best Practices","text":"<ol> <li>Always provide clear docstrings for your tools</li> <li>Use type hints for better validation</li> <li>Handle errors appropriately in your tool implementations</li> <li>Use tags to organize related tools</li> <li>Consider async implementations for I/O-bound operations</li> </ol>"},{"location":"api/","title":"Overview","text":""},{"location":"api/#api-reference","title":"API Reference","text":"<p>Complete API documentation for universal-mcp, generated from source code docstrings.</p>"},{"location":"api/#overview","title":"Overview","text":"<p>This section provides detailed documentation for all public classes, methods, and functions in universal-mcp. The documentation is automatically generated from source code using mkdocstrings.</p>"},{"location":"api/#core-modules","title":"Core Modules","text":""},{"location":"api/#applications","title":"Applications","text":"<p>Applications API - Base classes for creating API integrations</p> <ul> <li><code>BaseApplication</code> - Abstract base for all applications</li> <li><code>APIApplication</code> - REST API wrapper with HTTP client</li> <li><code>GraphQLApplication</code> - GraphQL API wrapper with GQL client</li> </ul>"},{"location":"api/#integrations","title":"Integrations","text":"<p>Integrations API - Authentication and credential management</p> <ul> <li><code>Integration</code> - Base integration class</li> <li><code>ApiKeyIntegration</code> - Simple API key authentication</li> <li><code>OAuthIntegration</code> - OAuth 2.0 flow implementation</li> <li><code>AgentRIntegration</code> - Platform-managed credentials</li> </ul>"},{"location":"api/#tools","title":"Tools","text":"<p>Tools API - Tool definition and management</p> <ul> <li><code>Tool</code> - Individual tool wrapper</li> <li><code>ToolManager</code> - Central tool registry</li> <li><code>FuncMetadata</code> - Function metadata extraction</li> </ul>"},{"location":"api/#servers","title":"Servers","text":"<p>Servers API - MCP server implementations</p> <ul> <li><code>BaseServer</code> - Abstract MCP server base</li> <li><code>LocalServer</code> - Multi-application YAML-configured server</li> <li><code>SingleMCPServer</code> - Single application wrapper</li> </ul>"},{"location":"api/#stores","title":"Stores","text":"<p>Stores API - Credential storage backends</p> <ul> <li><code>BaseStore</code> - Abstract storage interface</li> <li><code>MemoryStore</code> - In-memory storage</li> <li><code>EnvironmentStore</code> - Environment variable storage</li> <li><code>KeyringStore</code> - System keyring storage</li> </ul>"},{"location":"api/#supporting-modules","title":"Supporting Modules","text":""},{"location":"api/#configuration","title":"Configuration","text":"<p>Configuration API - Pydantic configuration models</p> <ul> <li><code>ServerConfig</code> - Server configuration</li> <li><code>AppConfig</code> - Application configuration</li> <li><code>IntegrationConfig</code> - Integration configuration</li> <li><code>StoreConfig</code> - Store configuration</li> </ul>"},{"location":"api/#registry","title":"Registry","text":"<p>Registry API - Tool registry implementations</p> <ul> <li><code>ToolRegistry</code> - Abstract registry interface</li> <li><code>LocalRegistry</code> - Local tool storage</li> </ul>"},{"location":"api/#adapters","title":"Adapters","text":"<p>Adapters API - Tool format converters</p> <ul> <li>MCP adapter - Native format</li> <li>LangChain adapter - LangChain tool format</li> <li>OpenAI adapter - OpenAI function calling format</li> </ul>"},{"location":"api/#oauth-client","title":"OAuth Client","text":"<p>OAuth Client API - OAuth flow implementation</p> <ul> <li><code>CallbackServer</code> - OAuth callback handler</li> <li><code>TokenStore</code> - Token storage utilities</li> </ul>"},{"location":"api/#exceptions","title":"Exceptions","text":"<p>Exceptions API - Exception hierarchy</p> <ul> <li><code>UniversalMCPError</code> - Base exception</li> <li><code>NotAuthorizedError</code> - Authentication errors</li> <li><code>ToolNotFoundError</code> - Tool lookup errors</li> <li>And more...</li> </ul>"},{"location":"api/#types","title":"Types","text":"<p>Types API - Type definitions and enums</p> <ul> <li>Enums for integration types, store types, etc.</li> <li>Type aliases and constants</li> </ul>"},{"location":"api/#usage-examples","title":"Usage Examples","text":"<p>Each API page includes:</p> <ul> <li>Class signatures with type hints</li> <li>Method documentation from docstrings</li> <li>Parameter descriptions with types and defaults</li> <li>Return value documentation</li> <li>Usage examples where applicable</li> </ul>"},{"location":"api/#navigation-tips","title":"Navigation Tips","text":"<ul> <li>Use the search bar (top right) to find specific classes or methods</li> <li>Click on type hints to navigate to related classes</li> <li>Check the Architecture section for conceptual diagrams</li> <li>See the main documentation for usage guides</li> </ul>"},{"location":"api/#contributing","title":"Contributing","text":"<p>When adding new features to universal-mcp:</p> <ol> <li>Write clear docstrings following Google style</li> <li>Include type hints on all public methods</li> <li>Document parameters, return values, and exceptions</li> <li>Add usage examples for complex functionality</li> </ol> <p>The API documentation will be automatically generated from your docstrings.</p>"},{"location":"api/adapters/","title":"Adapters","text":""},{"location":"api/adapters/#adapters-api","title":"Adapters API","text":"<p>Tool format converters for different AI frameworks.</p>"},{"location":"api/adapters/#overview","title":"Overview","text":"<p>Adapters convert universal-mcp tools to different formats: - MCP Adapter: Native MCP format (default) - LangChain Adapter: LangChain tool format - OpenAI Adapter: OpenAI function calling format</p>"},{"location":"api/adapters/#adapters-module","title":"Adapters Module","text":""},{"location":"api/adapters/#universal_mcp.tools.adapters.convert_tools","title":"convert_tools","text":"<pre><code>convert_tools(\n    tools: list[Tool], format: ToolFormat\n) -&gt; list[Any]\n</code></pre> <p>Convert a list of Tool objects to a specified format.</p>"},{"location":"api/adapters/#universal_mcp.tools.adapters.convert_to_native_tool","title":"convert_to_native_tool","text":"<pre><code>convert_to_native_tool(tool: Tool) -&gt; Callable[..., Any]\n</code></pre> <p>Decorator to convert a Tool object to a native tool.</p>"},{"location":"api/adapters/#universal_mcp.tools.adapters.format_to_mcp_result","title":"format_to_mcp_result","text":"<pre><code>format_to_mcp_result(result: Any) -&gt; list[TextContent]\n</code></pre> <p>Format tool result into TextContent list.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Any</code> <p>Raw tool result</p> required <p>Returns:</p> Type Description <code>list[TextContent]</code> <p>List of TextContent objects</p>"},{"location":"api/adapters/#universal_mcp.tools.adapters.convert_tool_to_openai_tool","title":"convert_tool_to_openai_tool","text":"<pre><code>convert_tool_to_openai_tool(tool: Tool)\n</code></pre> <p>Convert a Tool object to an OpenAI function.</p>"},{"location":"api/adapters/#universal_mcp.tools.adapters.transform_mcp_tool_to_openai_tool","title":"transform_mcp_tool_to_openai_tool","text":"<pre><code>transform_mcp_tool_to_openai_tool(mcp_tool: Tool)\n</code></pre> <p>Convert an MCP tool to an OpenAI tool.</p>"},{"location":"api/adapters/#usage-examples","title":"Usage Examples","text":""},{"location":"api/adapters/#mcp-format-native","title":"MCP Format (Native)","text":"<pre><code>from universal_mcp.tools import Tool\n\ndef get_weather(city: str) -&gt; dict:\n    \"\"\"Get weather for a city.\"\"\"\n    return {\"temp\": 72, \"condition\": \"sunny\"}\n\ntool = Tool.from_function(get_weather)\n\n# MCP format (default)\nmcp_format = tool.to_mcp()\nprint(mcp_format)\n# {\n#   \"name\": \"get_weather\",\n#   \"description\": \"Get weather for a city\",\n#   \"inputSchema\": {\n#     \"type\": \"object\",\n#     \"properties\": {\n#       \"city\": {\"type\": \"string\"}\n#     },\n#     \"required\": [\"city\"]\n#   }\n# }\n</code></pre>"},{"location":"api/adapters/#langchain-format","title":"LangChain Format","text":"<pre><code>from universal_mcp.tools.adapters import to_langchain\n\n# Convert tool to LangChain format\nlangchain_tool = to_langchain(tool)\n\n# Use with LangChain\nfrom langchain.agents import initialize_agent\n\nagent = initialize_agent(\n    tools=[langchain_tool],\n    llm=llm,\n    agent=\"zero-shot-react-description\"\n)\n</code></pre>"},{"location":"api/adapters/#openai-function-format","title":"OpenAI Function Format","text":"<pre><code>from universal_mcp.tools.adapters import to_openai\n\n# Convert tool to OpenAI function format\nopenai_function = to_openai(tool)\n\n# Use with OpenAI API\nimport openai\n\nresponse = openai.ChatCompletion.create(\n    model=\"gpt-4\",\n    messages=[...],\n    functions=[openai_function]\n)\n</code></pre>"},{"location":"api/adapters/#batch-conversion","title":"Batch Conversion","text":"<pre><code>from universal_mcp.tools.adapters import convert_tools\n\ntools = [tool1, tool2, tool3]\n\n# Convert all to LangChain\nlangchain_tools = convert_tools(tools, format=\"langchain\")\n\n# Convert all to OpenAI\nopenai_functions = convert_tools(tools, format=\"openai\")\n</code></pre>"},{"location":"api/adapters/#related-documentation","title":"Related Documentation","text":"<ul> <li>Tools API - Tool creation</li> <li>Applications API - Creating tools</li> </ul>"},{"location":"api/applications/","title":"Applications","text":""},{"location":"api/applications/#applications-api","title":"Applications API","text":"<p>Applications are the core abstraction for wrapping external APIs and services. They expose tools (callable functions) that AI agents can invoke.</p>"},{"location":"api/applications/#baseapplication","title":"BaseApplication","text":"<p>               Bases: <code>ABC</code></p> <p>Defines the foundational structure for applications in Universal MCP.</p> <p>This abstract base class (ABC) outlines the common interface and core functionality that all concrete application classes must implement. It handles basic initialization, such as setting the application name, and mandates the implementation of a method to list available tools. Analytics for application loading are also tracked here.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The unique name identifying the application.</p>"},{"location":"api/applications/#universal_mcp.applications.application.BaseApplication.__init__","title":"__init__","text":"<pre><code>__init__(name: str, **kwargs: Any) -&gt; None\n</code></pre> <p>Initializes the BaseApplication.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique name for this application instance.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments that might be specific              to the concrete application implementation. These are              logged but not directly used by BaseApplication.</p> <code>{}</code>"},{"location":"api/applications/#universal_mcp.applications.application.BaseApplication.list_tools","title":"list_tools  <code>abstractmethod</code>","text":"<pre><code>list_tools() -&gt; list[Callable]\n</code></pre> <p>Lists all tools provided by this application.</p> <p>This method must be implemented by concrete subclasses to return a list of callable tool objects that the application exposes.</p> <p>Returns:</p> Type Description <code>list[Callable]</code> <p>list[Callable]: A list of callable objects, where each callable             represents a tool offered by the application.</p>"},{"location":"api/applications/#apiapplication","title":"APIApplication","text":"<p>               Bases: <code>BaseApplication</code></p> <p>Base class for applications interacting with RESTful HTTP APIs.</p> <p>Extends <code>BaseApplication</code> to provide functionalities specific to API-based integrations. This includes managing an <code>httpx.Client</code> for making HTTP requests, handling authentication headers, processing responses, and offering convenient methods for common HTTP verbs (GET, POST, PUT, DELETE, PATCH).</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the application.</p> <code>integration</code> <code>Integration | None</code> <p>An optional Integration object responsible for managing authentication and credentials.</p> <code>default_timeout</code> <code>int</code> <p>The default timeout in seconds for HTTP requests.</p> <code>base_url</code> <code>str</code> <p>The base URL for the API endpoint. This should be             set by the subclass.</p> <code>_client</code> <code>Client | None</code> <p>The internal httpx client instance.</p>"},{"location":"api/applications/#universal_mcp.applications.application.APIApplication.__init__","title":"__init__","text":"<pre><code>__init__(\n    name: str,\n    integration: Integration | None = None,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Initializes the APIApplication.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique name for this application instance.</p> required <code>integration</code> <code>Integration | None</code> <p>An Integration object to handle authentication. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to the              BaseApplication.</p> <code>{}</code>"},{"location":"api/applications/#universal_mcp.applications.application.APIApplication._get_headers","title":"_get_headers","text":"<pre><code>_get_headers() -&gt; dict[str, str]\n</code></pre> <p>Constructs HTTP headers for API requests based on the integration.</p> <p>Retrieves credentials from the configured <code>integration</code> and attempts to create appropriate authentication headers. It supports direct header injection, API keys (as Bearer tokens), and access tokens (as Bearer tokens).</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: A dictionary of HTTP headers. Returns an empty             dictionary if no integration is configured or if             no suitable credentials are found.</p>"},{"location":"api/applications/#graphqlapplication","title":"GraphQLApplication","text":"<p>               Bases: <code>BaseApplication</code></p> <p>Base class for applications interacting with GraphQL APIs.</p> <p>Extends <code>BaseApplication</code> to facilitate interactions with services that provide a GraphQL endpoint. It manages a <code>gql.Client</code> for executing queries and mutations, handles authentication headers similarly to <code>APIApplication</code>, and provides dedicated methods for GraphQL operations.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the application.</p> <code>base_url</code> <code>str</code> <p>The complete URL of the GraphQL endpoint.</p> <code>integration</code> <code>Integration | None</code> <p>An optional Integration object for managing authentication.</p> <code>_client</code> <code>Client | None</code> <p>The internal <code>gql.Client</code> instance.</p>"},{"location":"api/applications/#universal_mcp.applications.application.GraphQLApplication.__init__","title":"__init__","text":"<pre><code>__init__(\n    name: str,\n    base_url: str,\n    integration: Integration | None = None,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Initializes the GraphQLApplication.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique name for this application instance.</p> required <code>base_url</code> <code>str</code> <p>The full URL of the GraphQL endpoint.</p> required <code>integration</code> <code>Integration | None</code> <p>An Integration object to handle authentication. Defaults to None.</p> <code>None</code> <code>client</code> <code>Client | None</code> <p>An existing <code>gql.Client</code> instance. If None, a new client will be created on demand. Defaults to None.</p> required <code>async_client</code> <code>Client | None</code> <p>An existing async <code>gql.Client</code> instance. If None, a new client will be created on demand. Defaults to None.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to the              BaseApplication.</p> <code>{}</code>"},{"location":"api/applications/#usage-examples","title":"Usage Examples","text":""},{"location":"api/applications/#creating-a-rest-api-application","title":"Creating a REST API Application","text":"<pre><code>from universal_mcp.applications import APIApplication\nfrom universal_mcp.integrations import ApiKeyIntegration\nfrom universal_mcp.stores import KeyringStore\n\nclass GitHubApp(APIApplication):\n    def __init__(self):\n        store = KeyringStore(service_name=\"github\")\n        integration = ApiKeyIntegration(\n            name=\"github_api_key\",\n            store=store,\n            api_key_name=\"GITHUB_TOKEN\"\n        )\n\n        super().__init__(\n            name=\"github\",\n            integration=integration\n        )\n        self.base_url = \"https://api.github.com\"\n\n    def list_tools(self):\n        return [\n            self.create_issue,\n            self.list_repositories,\n        ]\n\n    def create_issue(\n        self,\n        repo: str,\n        title: str,\n        body: str\n    ) -&gt; dict:\n        \"\"\"Create a GitHub issue.\n\n        Args:\n            repo: Repository in format \"owner/repo\"\n            title: Issue title\n            body: Issue description\n\n        Returns:\n            Created issue data including number and URL\n        \"\"\"\n        return self.post(\n            f\"/repos/{repo}/issues\",\n            json={\"title\": title, \"body\": body}\n        )\n\n    def list_repositories(self, username: str) -&gt; list[dict]:\n        \"\"\"List user's public repositories.\n\n        Args:\n            username: GitHub username\n\n        Returns:\n            List of repository objects\n        \"\"\"\n        return self.get(f\"/users/{username}/repos\")\n</code></pre>"},{"location":"api/applications/#creating-a-graphql-application","title":"Creating a GraphQL Application","text":"<pre><code>from universal_mcp.applications import GraphQLApplication\nfrom universal_mcp.integrations import OAuthIntegration\n\nclass GitHubGraphQLApp(GraphQLApplication):\n    def __init__(self):\n        integration = OAuthIntegration(\n            name=\"github_oauth\",\n            client_id=\"...\",\n            client_secret=\"...\",\n            auth_url=\"https://github.com/login/oauth/authorize\",\n            token_url=\"https://github.com/login/oauth/access_token\",\n            scopes=[\"repo\"]\n        )\n\n        super().__init__(\n            name=\"github_graphql\",\n            integration=integration\n        )\n        self.graphql_url = \"https://api.github.com/graphql\"\n\n    def list_tools(self):\n        return [self.get_user_info]\n\n    def get_user_info(self, username: str) -&gt; dict:\n        \"\"\"Get user information via GraphQL.\n\n        Args:\n            username: GitHub username\n\n        Returns:\n            User profile data\n        \"\"\"\n        query = '''\n        query($username: String!) {\n            user(login: $username) {\n                name\n                bio\n                company\n                location\n            }\n        }\n        '''\n        return self.execute_query(\n            query,\n            variables={\"username\": username}\n        )\n</code></pre>"},{"location":"api/applications/#application-without-authentication","title":"Application Without Authentication","text":"<p>For public APIs that don't require authentication:</p> <pre><code>from universal_mcp.applications import APIApplication\n\nclass PublicAPIApp(APIApplication):\n    def __init__(self):\n        # No integration needed\n        super().__init__(name=\"public_api\")\n        self.base_url = \"https://api.publicapis.org\"\n\n    def list_tools(self):\n        return [self.random_api]\n\n    def random_api(self) -&gt; dict:\n        \"\"\"Get a random API from the public APIs list.\n\n        Returns:\n            Random API entry\n        \"\"\"\n        return self.get(\"/random\")\n</code></pre>"},{"location":"api/applications/#best-practices","title":"Best Practices","text":""},{"location":"api/applications/#1-set-base-url","title":"1. Set Base URL","text":"<p>Always set <code>base_url</code> in <code>__init__</code>:</p> <pre><code>def __init__(self):\n    super().__init__(name=\"myapp\")\n    self.base_url = \"https://api.example.com\"  # Set this!\n</code></pre>"},{"location":"api/applications/#2-handle-errors","title":"2. Handle Errors","text":"<p>Use try/except for better error messages:</p> <pre><code>def create_user(self, name: str) -&gt; dict:\n    \"\"\"Create a user.\"\"\"\n    try:\n        return self.post(\"/users\", json={\"name\": name})\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == 409:\n            raise ValueError(f\"User {name} already exists\")\n        raise\n</code></pre>"},{"location":"api/applications/#3-document-return-types","title":"3. Document Return Types","text":"<p>Be specific about return types in docstrings:</p> <pre><code>def get_user(self, user_id: int) -&gt; dict:\n    \"\"\"Get user by ID.\n\n    Returns:\n        dict: User object containing:\n            - id (int): User ID\n            - name (str): Full name\n            - email (str): Email address\n    \"\"\"\n</code></pre>"},{"location":"api/applications/#4-use-type-hints","title":"4. Use Type Hints","text":"<p>Always include type hints for better schema generation:</p> <pre><code>from typing import Literal\n\ndef update_status(\n    self,\n    status: Literal[\"active\", \"inactive\", \"pending\"]\n) -&gt; dict:\n    \"\"\"Update status.\"\"\"\n    # Type hint generates enum in schema\n</code></pre>"},{"location":"api/applications/#related-documentation","title":"Related Documentation","text":"<ul> <li>Architecture: Tool Registration - How tools are discovered</li> <li>Integrations API - Authentication setup</li> <li>Tools API - Tool system details</li> </ul>"},{"location":"api/client/","title":"OAuth Client","text":""},{"location":"api/client/#oauth-client-api","title":"OAuth Client API","text":"<p>OAuth 2.0 flow implementation with callback server and token storage.</p>"},{"location":"api/client/#callbackserver","title":"CallbackServer","text":"<p>A singleton HTTP server to manage OAuth 2.0 redirect callbacks.</p> <p>This server runs in a background thread, listening on a specified localhost port. It uses the <code>CallbackHandler</code> to capture the authorization code or error returned by an OAuth 2.0 provider after user authentication.</p> <p>Being a Singleton, only one instance of this server will run per application, even if instantiated multiple times.</p> <p>Attributes:</p> Name Type Description <code>port</code> <code>int</code> <p>The port number on localhost where the server listens.</p> <code>server</code> <code>HTTPServer | None</code> <p>The underlying <code>HTTPServer</code> instance. None if the server is not running.</p> <code>thread</code> <code>Thread | None</code> <p>The background thread in which the server runs. None if the server is not running.</p> <code>callback_data</code> <code>dict</code> <p>A dictionary to store data received from the OAuth callback (e.g., <code>authorization_code</code>, <code>state</code>, <code>error</code>). This is shared with the <code>CallbackHandler</code>.</p> <code>_running</code> <code>bool</code> <p>A flag indicating whether the server is currently started and listening.</p>"},{"location":"api/client/#universal_mcp.client.oauth.CallbackServer.__init__","title":"__init__","text":"<pre><code>__init__(port: int = 3000)\n</code></pre> <p>Initializes the CallbackServer.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>The port number on localhost for the server to listen on. Defaults to 3000.</p> <code>3000</code>"},{"location":"api/client/#universal_mcp.client.oauth.CallbackServer.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Starts the HTTP callback server in a background daemon thread.</p> <p>If the server is not already running, it initializes an <code>HTTPServer</code> with a specialized <code>CallbackHandler</code> and starts it in a new daemon thread. This allows the main application flow to continue while waiting for the OAuth callback.</p>"},{"location":"api/client/#universal_mcp.client.oauth.CallbackServer.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stops the HTTP callback server and cleans up resources.</p> <p>Shuts down the <code>HTTPServer</code> and waits for its background thread to complete.</p>"},{"location":"api/client/#universal_mcp.client.oauth.CallbackServer.wait_for_callback","title":"wait_for_callback","text":"<pre><code>wait_for_callback(timeout: int = 300) -&gt; str\n</code></pre> <p>Waits for the OAuth callback to provide an authorization code.</p> <p>This method polls the <code>self.callback_data</code> dictionary until an authorization code is received or an error is reported by the <code>CallbackHandler</code>, or until the timeout is reached.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>The maximum time in seconds to wait for the callback. Defaults to 300 seconds (5 minutes).</p> <code>300</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The received authorization code.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an error is reported in the callback        (e.g., \"OAuth error: \").</p> <code>Exception</code> <p>If the timeout is reached before a code or error        is received (e.g., \"Timeout waiting for OAuth callback\").</p>"},{"location":"api/client/#universal_mcp.client.oauth.CallbackServer.get_state","title":"get_state","text":"<pre><code>get_state() -&gt; str | None\n</code></pre> <p>Retrieves the 'state' parameter received during the OAuth callback.</p> <p>The state parameter is often used to prevent cross-site request forgery (CSRF) attacks by matching its value with one sent in the initial authorization request.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The 'state' parameter value if received, otherwise None.</p>"},{"location":"api/client/#tokenstore","title":"TokenStore","text":"<p>               Bases: <code>TokenStorage</code></p> <p>Persistent storage for OAuth tokens and client information using KeyringStore.</p> <p>This class implements the <code>mcp.client.auth.TokenStorage</code> interface, providing a mechanism to securely store and retrieve OAuth 2.0 tokens (as <code>OAuthToken</code> objects) and OAuth client registration details (as <code>OAuthClientInformationFull</code> objects).</p> <p>It utilizes an underlying <code>KeyringStore</code> instance, which typically delegates to the operating system's secure credential management system (e.g., macOS Keychain, Windows Credential Manager, Linux KWallet). This ensures that sensitive token data is stored securely and persistently.</p> <p>Attributes:</p> Name Type Description <code>store</code> <code>KeyringStore</code> <p>The <code>KeyringStore</code> instance used for actually storing and retrieving the serialized token and client info data.</p>"},{"location":"api/client/#universal_mcp.client.token_store.TokenStore.__init__","title":"__init__","text":"<pre><code>__init__(store: KeyringStore)\n</code></pre> <p>Initializes the TokenStore.</p> <p>Parameters:</p> Name Type Description Default <code>store</code> <code>KeyringStore</code> <p>An instance of <code>KeyringStore</code> that will be used for the actual persistence of tokens and client information.</p> required"},{"location":"api/client/#universal_mcp.client.token_store.TokenStore.get_tokens","title":"get_tokens  <code>async</code>","text":"<pre><code>get_tokens() -&gt; OAuthToken | None\n</code></pre> <p>Retrieves OAuth tokens from the persistent KeyringStore.</p> <p>Fetches the JSON string representation of tokens from the store using the key \"tokens\" and deserializes it into an <code>OAuthToken</code> object.</p> <p>Returns:</p> Type Description <code>OAuthToken | None</code> <p>OAuthToken | None: The deserialized <code>OAuthToken</code> object if found                and successfully parsed, otherwise None.</p>"},{"location":"api/client/#universal_mcp.client.token_store.TokenStore.set_tokens","title":"set_tokens  <code>async</code>","text":"<pre><code>set_tokens(tokens: OAuthToken) -&gt; None\n</code></pre> <p>Serializes OAuth tokens to JSON and saves them to the KeyringStore.</p> <p>The provided <code>OAuthToken</code> object is converted to its JSON string representation and stored in the <code>KeyringStore</code> under the key \"tokens\".</p> <p>Parameters:</p> Name Type Description Default <code>tokens</code> <code>OAuthToken</code> <p>The <code>OAuthToken</code> object to store.</p> required"},{"location":"api/client/#universal_mcp.client.token_store.TokenStore.get_client_info","title":"get_client_info  <code>async</code>","text":"<pre><code>get_client_info() -&gt; OAuthClientInformationFull | None\n</code></pre> <p>Retrieves OAuth client information from the persistent KeyringStore.</p> <p>Fetches the JSON string representation of client information from the store using the key \"client_info\" and deserializes it into an <code>OAuthClientInformationFull</code> object.</p> <p>Returns:</p> Type Description <code>OAuthClientInformationFull | None</code> <p>OAuthClientInformationFull | None: The deserialized object if found                               and successfully parsed, otherwise None.</p>"},{"location":"api/client/#universal_mcp.client.token_store.TokenStore.set_client_info","title":"set_client_info  <code>async</code>","text":"<pre><code>set_client_info(\n    client_info: OAuthClientInformationFull,\n) -&gt; None\n</code></pre> <p>Serializes OAuth client information to JSON and saves it to KeyringStore.</p> <p>The provided <code>OAuthClientInformationFull</code> object is converted to its JSON string representation and stored in the <code>KeyringStore</code> under the key \"client_info\".</p> <p>Parameters:</p> Name Type Description Default <code>client_info</code> <code>OAuthClientInformationFull</code> <p>The client information object to store.</p> required"},{"location":"api/client/#usage-examples","title":"Usage Examples","text":""},{"location":"api/client/#oauth-flow-with-callback-server","title":"OAuth Flow with Callback Server","text":"<pre><code>from universal_mcp.client.oauth import CallbackServer\nfrom universal_mcp.client.token_store import TokenStore\n\n# Start callback server\ncallback = CallbackServer(port=8080)\ncallback.start()\n\n# Build authorization URL\nauth_url = (\n    f\"https://provider.com/oauth/authorize\"\n    f\"?client_id={client_id}\"\n    f\"&amp;redirect_uri=http://localhost:8080/callback\"\n    f\"&amp;scope=read+write\"\n)\n\nprint(f\"Visit: {auth_url}\")\n\n# Wait for callback (blocks until user authorizes)\ncode = callback.wait_for_code(timeout=300)\n\ncallback.stop()\n\n# Exchange code for token\n# ... token exchange logic ...\n</code></pre>"},{"location":"api/client/#token-storage","title":"Token Storage","text":"<pre><code>from universal_mcp.client.token_store import TokenStore\n\nstore = TokenStore()\n\n# Store tokens\nstore.save_token(\"github\", {\n    \"access_token\": \"gho_...\",\n    \"refresh_token\": \"ghr_...\",\n    \"expires_at\": 1234567890\n})\n\n# Retrieve tokens\ntokens = store.load_token(\"github\")\n\n# Check if token is expired\nimport time\nif tokens[\"expires_at\"] &lt; time.time():\n    # Token expired, refresh needed\n    pass\n</code></pre>"},{"location":"api/client/#related-documentation","title":"Related Documentation","text":"<ul> <li>Integrations API - OAuth integration using these components</li> <li>Architecture: Authentication Flow - Complete OAuth flow</li> </ul>"},{"location":"api/config/","title":"Configuration","text":""},{"location":"api/config/#configuration-api","title":"Configuration API","text":"<p>Pydantic models for server and application configuration.</p>"},{"location":"api/config/#serverconfig","title":"ServerConfig","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Core configuration settings for the Universal MCP server.</p> <p>Manages server behavior, including its name, description, connection to AgentR (if applicable), transport protocol, network settings (port/host), applications to load, default credential store, and logging verbosity. Settings can be loaded from environment variables or a .env file.</p>"},{"location":"api/config/#universal_mcp.config.ServerConfig.validate_log_level","title":"validate_log_level","text":"<pre><code>validate_log_level(v: str) -&gt; str\n</code></pre> <p>Validates and normalizes the log_level field.</p>"},{"location":"api/config/#universal_mcp.config.ServerConfig.validate_port","title":"validate_port","text":"<pre><code>validate_port(v: int) -&gt; int\n</code></pre> <p>Validates the port number is within the valid range.</p>"},{"location":"api/config/#universal_mcp.config.ServerConfig.load_json_config","title":"load_json_config  <code>classmethod</code>","text":"<pre><code>load_json_config(path: str = 'server_config.json') -&gt; Self\n</code></pre> <p>Loads server configuration from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the JSON configuration file. Defaults to \"local_config.json\".</p> <code>'server_config.json'</code> <p>Returns:</p> Name Type Description <code>ServerConfig</code> <code>Self</code> <p>An instance of ServerConfig populated with data           from the JSON file.</p>"},{"location":"api/config/#appconfig","title":"AppConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for a single application to be loaded by the MCP server.</p> <p>Defines an application's name (slug), its integration settings for authentication, and optionally, a list of specific actions (tools) it provides.</p>"},{"location":"api/config/#integrationconfig","title":"IntegrationConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the authentication and credential management for an application.</p> <p>Specifies how a particular application (<code>AppConfig</code>) should authenticate with its target service, including the authentication type (e.g., API key, OAuth) and where to find the necessary credentials.</p>"},{"location":"api/config/#storeconfig","title":"StoreConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Specifies the configuration for a credential or token store.</p> <p>Defines where and how sensitive information like API keys or OAuth tokens should be stored and retrieved.</p>"},{"location":"api/config/#usage-examples","title":"Usage Examples","text":""},{"location":"api/config/#complete-yaml-configuration","title":"Complete YAML Configuration","text":"<pre><code># Server-level settings\nserver:\n  name: \"My MCP Server\"\n  version: \"1.0.0\"\n  debug: false\n\n# Store configuration\nstore:\n  type: keyring\n  service_name: universal-mcp-prod\n\n# Application definitions\napplications:\n  # OAuth application\n  - name: github\n    module: universal_mcp.applications.github\n    class_name: GitHubApp\n    init_kwargs:\n      timeout: 30\n    integration:\n      type: oauth\n      client_id: ${GITHUB_CLIENT_ID}\n      client_secret: ${GITHUB_CLIENT_SECRET}\n      auth_url: https://github.com/login/oauth/authorize\n      token_url: https://github.com/login/oauth/access_token\n      scopes:\n        - repo\n        - user\n      callback_port: 8080\n\n  # API Key application\n  - name: slack\n    module: my_apps.slack\n    class_name: SlackApp\n    integration:\n      type: api_key\n      api_key_name: SLACK_BOT_TOKEN\n      headers:\n        Authorization: \"Bearer {api_key}\"\n\n  # No authentication\n  - name: public_api\n    module: my_apps.public\n    class_name: PublicAPIApp\n    # No integration needed\n\n# Global timeout settings\ntimeouts:\n  default: 30\n  max: 300\n</code></pre>"},{"location":"api/config/#loading-configuration","title":"Loading Configuration","text":"<pre><code>from universal_mcp.config import ServerConfig\n\n# From YAML file\nconfig = ServerConfig.from_yaml(\"config.yaml\")\n\n# From dict\nconfig = ServerConfig.from_dict({\n    \"store\": {\"type\": \"memory\"},\n    \"applications\": [...]\n})\n\n# Access fields\nprint(config.server.name)\nprint(config.store.type)\nfor app in config.applications:\n    print(f\"App: {app.name}\")\n</code></pre>"},{"location":"api/config/#environment-variable-substitution","title":"Environment Variable Substitution","text":"<p>Variables in format <code>${VAR_NAME}</code> are automatically replaced:</p> <pre><code>integration:\n  client_id: ${GITHUB_CLIENT_ID}  # Replaced with os.environ[\"GITHUB_CLIENT_ID\"]\n  client_secret: ${GITHUB_CLIENT_SECRET}\n</code></pre> <pre><code>import os\nos.environ[\"GITHUB_CLIENT_ID\"] = \"abc123\"\nos.environ[\"GITHUB_CLIENT_SECRET\"] = \"secret\"\n\nconfig = ServerConfig.from_yaml(\"config.yaml\")\nprint(config.applications[0].integration.client_id)  # \"abc123\"\n</code></pre>"},{"location":"api/config/#validation","title":"Validation","text":"<p>Pydantic validates configuration:</p> <pre><code>from universal_mcp.config import ServerConfig\nfrom pydantic import ValidationError\n\ntry:\n    config = ServerConfig.from_yaml(\"invalid.yaml\")\nexcept ValidationError as e:\n    print(\"Configuration errors:\")\n    for error in e.errors():\n        print(f\"  {error['loc']}: {error['msg']}\")\n</code></pre> <p>Example validation errors: </p><pre><code>Configuration errors:\n  store.type: value is not a valid enumeration member\n  applications.0.module: field required\n  applications.1.integration.client_id: field required\n</code></pre><p></p>"},{"location":"api/config/#configuration-examples","title":"Configuration Examples","text":""},{"location":"api/config/#minimal-configuration","title":"Minimal Configuration","text":"<pre><code>store:\n  type: memory\n\napplications:\n  - name: simple_app\n    module: my_module\n    class_name: MyApp\n</code></pre>"},{"location":"api/config/#multi-environment-configuration","title":"Multi-Environment Configuration","text":"<pre><code># config.prod.yaml\nstore:\n  type: keyring\n  service_name: myapp-prod\n\napplications:\n  - name: github\n    module: apps.github\n    class_name: GitHubApp\n    integration:\n      type: oauth\n      client_id: ${GITHUB_CLIENT_ID}\n      client_secret: ${GITHUB_CLIENT_SECRET}\n      # ... production settings\n</code></pre> <pre><code># config.dev.yaml\nstore:\n  type: memory\n\napplications:\n  - name: github\n    module: apps.github\n    class_name: GitHubApp\n    integration:\n      type: api_key\n      api_key_name: DEV_GITHUB_TOKEN\n</code></pre>"},{"location":"api/config/#application-specific-configuration","title":"Application-Specific Configuration","text":"<pre><code>applications:\n  - name: weather_api\n    module: apps.weather\n    class_name: WeatherApp\n\n    # Custom kwargs passed to __init__\n    init_kwargs:\n      api_version: \"2.5\"\n      units: \"metric\"\n      timeout: 10\n      cache_ttl: 3600\n\n    integration:\n      type: api_key\n      api_key_name: WEATHER_API_KEY\n</code></pre> <p>Application receives kwargs: </p><pre><code>class WeatherApp(APIApplication):\n    def __init__(\n        self,\n        name: str,\n        integration: Integration,\n        api_version: str = \"2.5\",\n        units: str = \"metric\",\n        **kwargs\n    ):\n        super().__init__(name, integration, **kwargs)\n        self.api_version = api_version\n        self.units = units\n</code></pre><p></p>"},{"location":"api/config/#programmatic-configuration","title":"Programmatic Configuration","text":""},{"location":"api/config/#building-config-in-code","title":"Building Config in Code","text":"<pre><code>from universal_mcp.config import (\n    ServerConfig,\n    AppConfig,\n    IntegrationConfig,\n    StoreConfig\n)\n\nconfig = ServerConfig(\n    store=StoreConfig(type=\"keyring\", service_name=\"my-app\"),\n    applications=[\n        AppConfig(\n            name=\"github\",\n            module=\"apps.github\",\n            class_name=\"GitHubApp\",\n            integration=IntegrationConfig(\n                type=\"oauth\",\n                client_id=\"...\",\n                client_secret=\"...\",\n                auth_url=\"https://github.com/login/oauth/authorize\",\n                token_url=\"https://github.com/login/oauth/access_token\",\n                scopes=[\"repo\"]\n            )\n        )\n    ]\n)\n\n# Use config\nfrom universal_mcp.servers import LocalServer\nserver = LocalServer.from_config_object(config)\n</code></pre>"},{"location":"api/config/#merging-configurations","title":"Merging Configurations","text":"<pre><code>def merge_configs(base_config, override_config):\n    \"\"\"Merge two configurations, override takes precedence.\"\"\"\n    base_dict = base_config.model_dump()\n    override_dict = override_config.model_dump()\n\n    # Deep merge logic\n    merged = {**base_dict, **override_dict}\n\n    return ServerConfig.from_dict(merged)\n\nbase = ServerConfig.from_yaml(\"base.yaml\")\noverride = ServerConfig.from_yaml(\"override.yaml\")\nfinal = merge_configs(base, override)\n</code></pre>"},{"location":"api/config/#integration-configuration-types","title":"Integration Configuration Types","text":""},{"location":"api/config/#api-key-integration","title":"API Key Integration","text":"<pre><code>integration:\n  type: api_key\n  api_key_name: MY_API_KEY\n\n  # Optional: custom headers\n  headers:\n    Authorization: \"Bearer {api_key}\"\n    X-API-Version: \"2024-01\"\n\n  # Optional: query parameter instead\n  query_param: \"api_key\"\n</code></pre>"},{"location":"api/config/#oauth-integration","title":"OAuth Integration","text":"<pre><code>integration:\n  type: oauth\n  client_id: ${CLIENT_ID}\n  client_secret: ${CLIENT_SECRET}\n  auth_url: https://provider.com/oauth/authorize\n  token_url: https://provider.com/oauth/token\n\n  # Required scopes\n  scopes:\n    - read\n    - write\n\n  # Optional settings\n  callback_port: 8080\n  callback_path: \"/oauth/callback\"\n</code></pre>"},{"location":"api/config/#agentr-integration","title":"AgentR Integration","text":"<pre><code>integration:\n  type: agentr\n  integration_id: github_integration_123\n  agentr_api_key: ${AGENTR_API_KEY}\n  agentr_url: https://api.agentr.io  # Optional\n</code></pre>"},{"location":"api/config/#store-configuration-types","title":"Store Configuration Types","text":""},{"location":"api/config/#keyring-store","title":"Keyring Store","text":"<pre><code>store:\n  type: keyring\n  service_name: my-app-name  # Required\n</code></pre>"},{"location":"api/config/#environment-store","title":"Environment Store","text":"<pre><code>store:\n  type: environment\n  # No additional config needed\n</code></pre>"},{"location":"api/config/#memory-store","title":"Memory Store","text":"<pre><code>store:\n  type: memory\n  # No additional config needed\n</code></pre>"},{"location":"api/config/#validation-rules","title":"Validation Rules","text":""},{"location":"api/config/#required-fields","title":"Required Fields","text":"<pre><code># ServerConfig requires:\n# - store (StoreConfig)\n# - applications (list of AppConfig)\n\n# AppConfig requires:\n# - name (str)\n# - module (str)\n# - class_name (str)\n\n# IntegrationConfig requires (varies by type):\n# - type (str)\n# - type=\"api_key\" requires: api_key_name\n# - type=\"oauth\" requires: client_id, client_secret, auth_url, token_url, scopes\n# - type=\"agentr\" requires: integration_id, agentr_api_key\n</code></pre>"},{"location":"api/config/#type-validation","title":"Type Validation","text":"<pre><code># Enums\nstore.type in [\"keyring\", \"environment\", \"memory\"]\nintegration.type in [\"api_key\", \"oauth\", \"agentr\"]\n\n# URLs\nauth_url: must be valid URL\ntoken_url: must be valid URL\n\n# Ports\ncallback_port: must be 1-65535\n\n# Lists\nscopes: must be list of strings\napplications: must be list of AppConfig\n</code></pre>"},{"location":"api/config/#configuration-best-practices","title":"Configuration Best Practices","text":""},{"location":"api/config/#1-use-environment-variables-for-secrets","title":"1. Use Environment Variables for Secrets","text":"<pre><code># Good\nintegration:\n  client_secret: ${CLIENT_SECRET}\n\n# Bad - secret in version control\nintegration:\n  client_secret: \"actual_secret_here\"\n</code></pre>"},{"location":"api/config/#2-separate-devprod-configs","title":"2. Separate Dev/Prod Configs","text":"<pre><code>config/\n  base.yaml          # Common settings\n  dev.yaml           # Development overrides\n  prod.yaml          # Production overrides\n  test.yaml          # Test settings\n</code></pre>"},{"location":"api/config/#3-validate-before-deployment","title":"3. Validate Before Deployment","text":"<pre><code>def validate_config(config_path):\n    try:\n        config = ServerConfig.from_yaml(config_path)\n        print(\"\u2713 Configuration valid\")\n        return True\n    except Exception as e:\n        print(f\"\u2717 Configuration invalid: {e}\")\n        return False\n\n# In CI/CD pipeline\nif not validate_config(\"config.prod.yaml\"):\n    exit(1)\n</code></pre>"},{"location":"api/config/#4-document-required-environment-variables","title":"4. Document Required Environment Variables","text":"<pre><code># config.yaml\n# Required environment variables:\n#   - GITHUB_CLIENT_ID: OAuth client ID from GitHub\n#   - GITHUB_CLIENT_SECRET: OAuth client secret\n#   - SLACK_BOT_TOKEN: Slack bot token from App settings\n\napplications:\n  - name: github\n    integration:\n      client_id: ${GITHUB_CLIENT_ID}\n      client_secret: ${GITHUB_CLIENT_SECRET}\n</code></pre>"},{"location":"api/config/#related-documentation","title":"Related Documentation","text":"<ul> <li>Servers API - Using configuration with servers</li> <li>Architecture: Server Initialization - How config is loaded</li> </ul>"},{"location":"api/exceptions/","title":"Exceptions","text":""},{"location":"api/exceptions/#exceptions-api","title":"Exceptions API","text":"<p>Exception hierarchy for universal-mcp errors.</p>"},{"location":"api/exceptions/#authentication-exceptions","title":"Authentication Exceptions","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when an action is attempted without necessary permissions.</p> <p>This typically occurs if a user or process tries to access a protected resource or perform an operation for which they lack the required authorization credentials or roles.</p>"},{"location":"api/exceptions/#universal_mcp.exceptions.NotAuthorizedError.__init__","title":"__init__","text":"<pre><code>__init__(message: str)\n</code></pre> <p>Initializes the NotAuthorizedError.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>A descriptive message explaining the authorization failure.</p> required"},{"location":"api/exceptions/#store-exceptions","title":"Store Exceptions","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for errors related to data or credential stores.</p> <p>This serves as a generic error for issues arising from operations on any storage backend (e.g., KeyringStore, EnvironmentStore). Specific store errors should ideally subclass this.</p> <p>               Bases: <code>StoreError</code></p> <p>Raised when a specified key cannot be found in a data or credential store.</p> <p>This is a common error when attempting to retrieve a piece of data (e.g., an API key, token, or client information) that does not exist under the given identifier.</p>"},{"location":"api/exceptions/#tool-exceptions","title":"Tool Exceptions","text":"<p>               Bases: <code>Exception</code></p> <p>Indicates an issue related to tool discovery, validation, or execution.</p> <p>This could be due to a tool not being found, failing during its operation, or having invalid configuration or arguments.</p> <p>               Bases: <code>Exception</code></p> <p>Raised when a tool is not found</p>"},{"location":"api/exceptions/#configuration-exceptions","title":"Configuration Exceptions","text":"<p>               Bases: <code>Exception</code></p> <p>Indicates an error was detected in application or server configuration.</p> <p>This can be due to missing required settings, invalid values for configuration parameters, or inconsistencies in the provided setup.</p>"},{"location":"api/exceptions/#signature-exceptions","title":"Signature Exceptions","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a cryptographic signature verification fails.</p> <p>This can occur during webhook validation or any other process that relies on verifying the authenticity and integrity of a message using a digital signature.</p>"},{"location":"api/exceptions/#usage-examples","title":"Usage Examples","text":""},{"location":"api/exceptions/#handling-authentication-errors","title":"Handling Authentication Errors","text":"<pre><code>from universal_mcp.exceptions import NotAuthorizedError, KeyNotFoundError\n\ntry:\n    creds = integration.get_credentials()\nexcept NotAuthorizedError:\n    print(\"Not authorized. Please run authorize():\")\n    print(integration.authorize())\nexcept KeyNotFoundError as e:\n    print(f\"Missing key: {e.key}\")\n    # Prompt user to set key\n</code></pre>"},{"location":"api/exceptions/#handling-tool-errors","title":"Handling Tool Errors","text":"<pre><code>from universal_mcp.exceptions import ToolNotFoundError, ToolError\n\ntry:\n    result = server.call_tool(\"my_tool\", args)\nexcept ToolNotFoundError:\n    print(\"Tool not found\")\n    # List available tools\n    print(\"Available:\", [t.name for t in server.list_tools()])\nexcept ToolError as e:\n    print(f\"Tool error: {e}\")\n</code></pre>"},{"location":"api/exceptions/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>Exception (Python base)\n\u251c\u2500\u2500 NotAuthorizedError\n\u251c\u2500\u2500 StoreError\n\u2502   \u2514\u2500\u2500 KeyNotFoundError\n\u251c\u2500\u2500 ToolError\n\u251c\u2500\u2500 ToolNotFoundError\n\u251c\u2500\u2500 ConfigurationError\n\u2514\u2500\u2500 InvalidSignature\n</code></pre>"},{"location":"api/exceptions/#related-documentation","title":"Related Documentation","text":"<ul> <li>Integrations API - Authentication errors</li> <li>Tools API - Tool execution errors</li> </ul>"},{"location":"api/integrations/","title":"Integrations","text":""},{"location":"api/integrations/#integrations-api","title":"Integrations API","text":"<p>Integrations handle authentication and credential management for applications.</p>"},{"location":"api/integrations/#integration-base","title":"Integration (Base)","text":"<p>Abstract base class for handling application integrations and authentication.</p> <p>This class defines a common interface for various authentication and authorization strategies an application might use to connect with external services. Subclasses implement specific mechanisms like API key handling, OAuth 2.0 flows, or delegation to platforms like AgentR.</p> <p>Each integration is associated with a name and can use a <code>BaseStore</code> instance for persisting credentials or other relevant data.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The unique name identifying this integration instance         (e.g., \"my_app_api_key\", \"github_oauth\").</p> <code>store</code> <code>BaseStore</code> <p>The storage backend (e.g., <code>MemoryStore</code>,            <code>KeyringStore</code>) used for persisting credentials.            Defaults to <code>MemoryStore</code> if not provided.</p>"},{"location":"api/integrations/#universal_mcp.integrations.integration.Integration.__init__","title":"__init__","text":"<pre><code>__init__(name: str, store: BaseStore | None = None)\n</code></pre> <p>Initializes the Integration.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique name/identifier for this integration instance.</p> required <code>store</code> <code>BaseStore | None</code> <p>A store instance for persisting credentials. Defaults to <code>MemoryStore()</code>.</p> <code>None</code>"},{"location":"api/integrations/#universal_mcp.integrations.integration.Integration.authorize","title":"authorize","text":"<pre><code>authorize() -&gt; str | dict[str, Any]\n</code></pre> <p>Initiates or provides details for the authorization process.</p> <p>The exact behavior and return type of this method depend on the specific integration subclass. It might return an authorization URL for the user to visit, parameters needed to construct such a URL, or instructions on how to manually provide credentials.</p> <p>Returns:</p> Type Description <code>str | dict[str, Any]</code> <p>str | dict[str, Any]: Typically, an authorization URL (str) or a                   dictionary containing parameters needed for                   the authorization flow.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If essential configuration for authorization is missing.</p> <code>NotImplementedError</code> <p>If the subclass does not implement this method.</p>"},{"location":"api/integrations/#universal_mcp.integrations.integration.Integration.authorize_async","title":"authorize_async  <code>async</code>","text":"<pre><code>authorize_async() -&gt; str | dict[str, Any]\n</code></pre> <p>Initiates or provides details for the authorization process asynchronously.</p> <p>Default implementation wraps the synchronous authorize method. Subclasses should override this if they support true async authorization.</p> <p>Returns:</p> Type Description <code>str | dict[str, Any]</code> <p>str | dict[str, Any]: Auth URL or parameters.</p>"},{"location":"api/integrations/#universal_mcp.integrations.integration.Integration.get_credentials","title":"get_credentials","text":"<pre><code>get_credentials() -&gt; dict[str, Any]\n</code></pre> <p>Retrieves the stored credentials for this integration.</p> <p>Fetches credentials associated with <code>self.name</code> from the <code>self.store</code>.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: A dictionary containing the credentials. The structure             of this dictionary is specific to the integration type.</p> <p>Raises:</p> Type Description <code>NotAuthorizedError</code> <p>If credentials are not found in the store                 or are otherwise invalid/inaccessible.</p> <code>KeyNotFoundError</code> <p>If the key (self.name) is not found in the store.</p>"},{"location":"api/integrations/#universal_mcp.integrations.integration.Integration.get_credentials_async","title":"get_credentials_async  <code>async</code>","text":"<pre><code>get_credentials_async() -&gt; dict[str, Any]\n</code></pre> <p>Retrieves the stored credentials for this integration asynchronously.</p> <p>Default implementation wraps the synchronous get_credentials method. Subclasses should override this if they support true async retrieval.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: A dictionary containing the credentials.</p>"},{"location":"api/integrations/#apikeyintegration","title":"ApiKeyIntegration","text":"<p>               Bases: <code>Integration</code></p> <p>Handles integrations that use a simple API key for authentication.</p> <p>This class manages storing and retrieving an API key. The key name is automatically sanitized (e.g., uppercased and suffixed with <code>_API_KEY</code>) before being used with the store.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The sanitized name used as the key for storing the API key.</p> <code>store</code> <code>BaseStore</code> <p>Store for persisting the API key.</p> <code>type</code> <code>str</code> <p>Set to \"api_key\".</p> <code>_api_key</code> <code>str | None</code> <p>Cached API key.</p>"},{"location":"api/integrations/#universal_mcp.integrations.integration.ApiKeyIntegration.__init__","title":"__init__","text":"<pre><code>__init__(\n    name: str, store: BaseStore | None = None, **kwargs\n)\n</code></pre> <p>Initializes ApiKeyIntegration.</p> <p>The provided <code>name</code> is sanitized (e.g., 'mykey' becomes 'MYKEY_API_KEY') to form the actual key used for storage.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The base name for the API key (e.g., \"TAVILY\").</p> required <code>store</code> <code>BaseStore | None</code> <p>Store for credentials.                                Defaults to <code>MemoryStore()</code>.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to the parent <code>Integration</code>.</p> <code>{}</code>"},{"location":"api/integrations/#universal_mcp.integrations.integration.ApiKeyIntegration.api_key","title":"api_key  <code>property</code> <code>writable</code>","text":"<pre><code>api_key: str\n</code></pre> <p>Retrieves the API key, loading it from the store if necessary.</p> <p>If the API key is not already cached in <code>_api_key</code>, it attempts to load it from <code>self.store</code> using <code>self.name</code> as the key.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The API key.</p> <p>Raises:</p> Type Description <code>NotAuthorizedError</code> <p>If the API key is not found in the store.                 The original <code>KeyNotFoundError</code> is chained.</p>"},{"location":"api/integrations/#universal_mcp.integrations.integration.ApiKeyIntegration.get_credentials","title":"get_credentials","text":"<pre><code>get_credentials() -&gt; dict[str, str]\n</code></pre> <p>Retrieves the API key and returns it in a standard dictionary format.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: A dictionary like <code>{\"api_key\": \"your_api_key_value\"}</code>.</p> <p>Raises:</p> Type Description <code>NotAuthorizedError</code> <p>If the API key cannot be retrieved.</p>"},{"location":"api/integrations/#universal_mcp.integrations.integration.ApiKeyIntegration.set_credentials","title":"set_credentials","text":"<pre><code>set_credentials(credentials: dict[str, Any]) -&gt; None\n</code></pre> <p>Sets the API key from a dictionary.</p> <p>Expects <code>credentials</code> to be a dictionary, typically containing an 'api_key' field, but it stores the entire dictionary as is under <code>self.name</code>. For direct API key setting, use the <code>api_key</code> property.</p> <p>Parameters:</p> Name Type Description Default <code>credentials</code> <code>dict[str, Any]</code> <p>A dictionary containing the API key or related credential information.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>credentials</code> is not a dictionary.</p>"},{"location":"api/integrations/#universal_mcp.integrations.integration.ApiKeyIntegration.authorize","title":"authorize","text":"<pre><code>authorize() -&gt; str\n</code></pre> <p>Provides instructions for setting the API key.</p> <p>Since API key setup is typically manual, this method returns a message guiding the user on how to provide the key.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A message instructing the user to provide the API key  for <code>self.name</code>.</p>"},{"location":"api/integrations/#oauthintegration","title":"OAuthIntegration","text":"<p>               Bases: <code>Integration</code></p> <p>Manages OAuth 2.0 authentication and authorization flows.</p> <p>This class implements the necessary steps for an OAuth 2.0 client, including generating authorization request parameters, handling the redirect callback from the authorization server, exchanging the authorization code for access/refresh tokens, and refreshing tokens.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the integration.</p> <code>store</code> <code>BaseStore</code> <p>Store for OAuth tokens.</p> <code>client_id</code> <code>str | None</code> <p>The OAuth 2.0 Client ID.</p> <code>client_secret</code> <code>str | None</code> <p>The OAuth 2.0 Client Secret.</p> <code>auth_url</code> <code>str | None</code> <p>The authorization server's endpoint URL.</p> <code>token_url</code> <code>str | None</code> <p>The token server's endpoint URL.</p> <code>scope</code> <code>str | None</code> <p>The requested OAuth scopes, space-separated.</p>"},{"location":"api/integrations/#universal_mcp.integrations.integration.OAuthIntegration.__init__","title":"__init__","text":"<pre><code>__init__(\n    name: str,\n    store: BaseStore | None = None,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    auth_url: str | None = None,\n    token_url: str | None = None,\n    scope: str | None = None,\n    **kwargs\n)\n</code></pre> <p>Initializes the OAuthIntegration.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The unique name for this integration instance.</p> required <code>store</code> <code>BaseStore | None</code> <p>Store for credentials.                                Defaults to <code>MemoryStore()</code>.</p> <code>None</code> <code>client_id</code> <code>str | None</code> <p>The OAuth 2.0 Client ID.</p> <code>None</code> <code>client_secret</code> <code>str | None</code> <p>The OAuth 2.0 Client Secret.</p> <code>None</code> <code>auth_url</code> <code>str | None</code> <p>The authorization server's endpoint URL.</p> <code>None</code> <code>token_url</code> <code>str | None</code> <p>The token server's endpoint URL.</p> <code>None</code> <code>scope</code> <code>str | None</code> <p>The requested OAuth scopes, space-separated.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to the parent <code>Integration</code>.</p> <code>{}</code>"},{"location":"api/integrations/#universal_mcp.integrations.integration.OAuthIntegration.get_credentials","title":"get_credentials","text":"<pre><code>get_credentials() -&gt; dict[str, Any] | None\n</code></pre> <p>Retrieves stored OAuth tokens for this integration.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>dict[str, Any] | None: A dictionary containing the OAuth tokens                   (e.g., <code>access_token</code>, <code>refresh_token</code>) if found,                   otherwise None.</p>"},{"location":"api/integrations/#universal_mcp.integrations.integration.OAuthIntegration.set_credentials","title":"set_credentials","text":"<pre><code>set_credentials(credentials: dict[str, Any]) -&gt; None\n</code></pre> <p>Stores OAuth tokens for this integration.</p> <p>Validates that essential fields like 'access_token' are present.</p> <p>Parameters:</p> Name Type Description Default <code>credentials</code> <code>dict[str, Any]</code> <p>A dictionary containing OAuth tokens. Must include at least 'access_token'.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>credentials</code> is not a dictionary or if 'access_token'         is missing.</p>"},{"location":"api/integrations/#universal_mcp.integrations.integration.OAuthIntegration.authorize","title":"authorize","text":"<pre><code>authorize() -&gt; dict[str, Any]\n</code></pre> <p>Constructs parameters required for the OAuth authorization request.</p> <p>These parameters are typically used to build the URL to which the user must be redirected to grant authorization.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: A dictionary containing the authorization endpoint URL             (<code>url</code>), query parameters (<code>params</code>), client secret,             and token URL.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If essential OAuth configuration like <code>client_id</code>,         <code>client_secret</code>, <code>auth_url</code>, or <code>token_url</code> is missing.</p>"},{"location":"api/integrations/#universal_mcp.integrations.integration.OAuthIntegration.handle_callback","title":"handle_callback","text":"<pre><code>handle_callback(code: str) -&gt; dict[str, Any]\n</code></pre> <p>Handles the OAuth callback by exchanging the authorization code for tokens.</p> <p>This method is called after the user authorizes the application and the authorization server redirects back with an authorization code.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>The authorization code received from the OAuth server.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: A dictionary containing the access token, refresh token             (if any), and other token response data. These are also             stored via <code>set_credentials</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If essential OAuth configuration is missing.</p> <code>HTTPStatusError</code> <p>If the token exchange request to <code>token_url</code> fails.</p>"},{"location":"api/integrations/#universal_mcp.integrations.integration.OAuthIntegration.refresh_token","title":"refresh_token","text":"<pre><code>refresh_token() -&gt; dict[str, Any]\n</code></pre> <p>Refreshes an expired access token using a stored refresh token.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: A dictionary containing the new access token,             refresh token, and other token response data.             These are also stored.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If essential OAuth configuration is missing.</p> <code>KeyError</code> <p>If a refresh token is not found in the stored credentials.</p> <code>HTTPStatusError</code> <p>If the token refresh request fails.</p>"},{"location":"api/integrations/#integrationfactory","title":"IntegrationFactory","text":"<p>A factory for creating integration instances.</p>"},{"location":"api/integrations/#universal_mcp.integrations.integration.IntegrationFactory.create","title":"create  <code>staticmethod</code>","text":"<pre><code>create(\n    app_name: str,\n    integration_type: str = \"api_key\",\n    **kwargs\n) -&gt; Integration\n</code></pre> <p>Create an integration instance.</p>"},{"location":"api/integrations/#usage-examples","title":"Usage Examples","text":""},{"location":"api/integrations/#api-key-integration","title":"API Key Integration","text":"<pre><code>from universal_mcp.integrations import ApiKeyIntegration\nfrom universal_mcp.stores import KeyringStore\n\n# Create store\nstore = KeyringStore(service_name=\"my-app\")\n\n# Create integration\nintegration = ApiKeyIntegration(\n    name=\"api_key\",\n    store=store,\n    api_key_name=\"MY_API_KEY\"\n)\n\n# First time: authorize (prompts user to set key)\nprint(integration.authorize())\n# Output: \"Please set MY_API_KEY environment variable or in keyring\"\n\n# After setting key in keyring:\n# store.set(\"MY_API_KEY\", \"sk_live_...\")\n\n# Get credentials\ncreds = integration.get_credentials()\nprint(creds)\n# Output: {\"api_key\": \"sk_live_...\"}\n</code></pre>"},{"location":"api/integrations/#custom-header-format","title":"Custom Header Format","text":"<pre><code>integration = ApiKeyIntegration(\n    name=\"api_key\",\n    store=store,\n    api_key_name=\"BEARER_TOKEN\",\n    headers={\"Authorization\": \"Bearer {api_key}\"}\n)\n\n# When used in application:\nheaders = integration.get_credentials()\n# Returns: {\"Authorization\": \"Bearer sk_live_...\"}\n</code></pre>"},{"location":"api/integrations/#oauth-20-integration","title":"OAuth 2.0 Integration","text":"<pre><code>from universal_mcp.integrations import OAuthIntegration\nfrom universal_mcp.stores import KeyringStore\n\nstore = KeyringStore(service_name=\"my-app\")\n\nintegration = OAuthIntegration(\n    name=\"github_oauth\",\n    store=store,\n    client_id=\"Iv1.abc123...\",\n    client_secret=\"secret_xyz...\",\n    auth_url=\"https://github.com/login/oauth/authorize\",\n    token_url=\"https://github.com/login/oauth/access_token\",\n    scopes=[\"repo\", \"user\"],\n    callback_port=8080\n)\n\n# First time: authorize\nauth_url = integration.authorize()\nprint(f\"Please visit: {auth_url}\")\n# Opens browser, user authorizes, callback receives code\n# Tokens automatically stored in keyring\n\n# Subsequent calls: get credentials\ncreds = integration.get_credentials()\nprint(creds)\n# Output: {\n#   \"access_token\": \"gho_...\",\n#   \"refresh_token\": \"ghr_...\",\n#   \"expires_at\": 1234567890\n# }\n\n# Token automatically refreshed when expired\n</code></pre>"},{"location":"api/integrations/#oauth-token-refresh","title":"OAuth Token Refresh","text":"<pre><code># Manual refresh (usually automatic)\nintegration.refresh_token()\n\n# Check if token is expired\nimport time\ncreds = integration.get_credentials()\nif creds.get(\"expires_at\", 0) &lt; time.time():\n    integration.refresh_token()\n    creds = integration.get_credentials()\n</code></pre>"},{"location":"api/integrations/#integration-factory","title":"Integration Factory","text":"<pre><code>from universal_mcp.integrations import IntegrationFactory\nfrom universal_mcp.stores import KeyringStore\n\nstore = KeyringStore()\n\n# Create API key integration\nfactory = IntegrationFactory()\nintegration = factory.create_integration(\n    integration_type=\"api_key\",\n    name=\"my_api\",\n    store=store,\n    api_key_name=\"API_KEY\"\n)\n\n# Create OAuth integration\nintegration = factory.create_integration(\n    integration_type=\"oauth\",\n    name=\"oauth_app\",\n    store=store,\n    client_id=\"...\",\n    client_secret=\"...\",\n    auth_url=\"https://...\",\n    token_url=\"https://...\",\n    scopes=[\"read\"]\n)\n</code></pre>"},{"location":"api/integrations/#integration-factories","title":"Integration Factories","text":""},{"location":"api/integrations/#creating-from-configuration","title":"Creating from Configuration","text":"<pre><code>from universal_mcp.integrations import create_integration\nfrom universal_mcp.stores import KeyringStore\n\nstore = KeyringStore()\n\n# API Key\nintegration = create_integration(\n    config={\n        \"type\": \"api_key\",\n        \"name\": \"my_api\",\n        \"api_key_name\": \"API_KEY\"\n    },\n    store=store\n)\n\n# OAuth\nintegration = create_integration(\n    config={\n        \"type\": \"oauth\",\n        \"name\": \"oauth_app\",\n        \"client_id\": \"...\",\n        \"client_secret\": \"...\",\n        \"auth_url\": \"https://...\",\n        \"token_url\": \"https://...\",\n        \"scopes\": [\"read\", \"write\"]\n    },\n    store=store\n)\n</code></pre>"},{"location":"api/integrations/#async-support","title":"Async Support","text":"<p>All integrations support async operations:</p> <pre><code># Async authorize\nauth_result = await integration.authorize_async()\n\n# Async get credentials\ncreds = await integration.get_credentials_async()\n</code></pre>"},{"location":"api/integrations/#error-handling","title":"Error Handling","text":"<pre><code>from universal_mcp.exceptions import NotAuthorizedError, KeyNotFoundError\n\ntry:\n    creds = integration.get_credentials()\nexcept NotAuthorizedError:\n    # No credentials found\n    print(\"Please authorize first:\")\n    print(integration.authorize())\nexcept KeyNotFoundError as e:\n    # Specific key missing\n    print(f\"Missing key: {e.key}\")\n</code></pre>"},{"location":"api/integrations/#best-practices","title":"Best Practices","text":""},{"location":"api/integrations/#1-use-keyringstore-for-production","title":"1. Use KeyringStore for Production","text":"<pre><code># Good - secure storage\nstore = KeyringStore(service_name=\"my-app\")\n\n# Avoid - credentials lost on restart\nstore = MemoryStore()\n</code></pre>"},{"location":"api/integrations/#2-handle-authorization-errors","title":"2. Handle Authorization Errors","text":"<pre><code>def ensure_authorized(integration):\n    try:\n        return integration.get_credentials()\n    except NotAuthorizedError:\n        print(\"Not authorized. Starting auth flow...\")\n        print(integration.authorize())\n        return integration.get_credentials()\n</code></pre>"},{"location":"api/integrations/#3-use-environment-variables-for-client-secrets","title":"3. Use Environment Variables for Client Secrets","text":"<pre><code>import os\n\nintegration = OAuthIntegration(\n    name=\"oauth\",\n    client_id=os.environ[\"CLIENT_ID\"],\n    client_secret=os.environ[\"CLIENT_SECRET\"],  # Never hardcode!\n    # ...\n)\n</code></pre>"},{"location":"api/integrations/#4-scope-minimization","title":"4. Scope Minimization","text":"<pre><code># Good - minimal scopes\nscopes=[\"repo:status\", \"user:email\"]\n\n# Bad - excessive permissions\nscopes=[\"repo\", \"admin:org\", \"delete:packages\"]\n</code></pre>"},{"location":"api/integrations/#related-documentation","title":"Related Documentation","text":"<ul> <li>Architecture: Authentication Flow - Detailed auth flows</li> <li>Applications API - Using integrations in apps</li> <li>Stores API - Storage backend options</li> </ul>"},{"location":"api/registry/","title":"Registry","text":""},{"location":"api/registry/#registry-api","title":"Registry API","text":"<p>Tool registry implementations for managing tool storage and discovery.</p>"},{"location":"api/registry/#toolregistry","title":"ToolRegistry","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for tool registries, defining a common interface and providing shared tool loading functionality.</p>"},{"location":"api/registry/#universal_mcp.tools.registry.ToolRegistry.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> <p>Initializes the registry and its internal tool manager.</p>"},{"location":"api/registry/#universal_mcp.tools.registry.ToolRegistry.list_all_apps","title":"list_all_apps  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>list_all_apps() -&gt; list[dict[str, Any]]\n</code></pre> <p>Get a list of all available apps from the platform.</p>"},{"location":"api/registry/#universal_mcp.tools.registry.ToolRegistry.get_app_details","title":"get_app_details  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_app_details(app_id: str) -&gt; dict[str, Any]\n</code></pre> <p>Get detailed information about a specific app.</p>"},{"location":"api/registry/#universal_mcp.tools.registry.ToolRegistry.search_apps","title":"search_apps  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>search_apps(\n    query: str,\n    limit: int = 2,\n    distance_threshold: float = 0.6,\n) -&gt; list[dict[str, Any]]\n</code></pre> <p>Search for apps by a query.</p>"},{"location":"api/registry/#universal_mcp.tools.registry.ToolRegistry.list_tools","title":"list_tools  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>list_tools(app_id: str) -&gt; list[dict[str, Any]]\n</code></pre> <p>List all tools available for a specific app.</p>"},{"location":"api/registry/#universal_mcp.tools.registry.ToolRegistry.search_tools","title":"search_tools  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>search_tools(\n    query: str,\n    limit: int = 2,\n    app_id: str | None = None,\n    distance_threshold: float = 0.6,\n) -&gt; list[dict[str, Any]]\n</code></pre> <p>Search for tools by a query, optionally filtered by an app.</p>"},{"location":"api/registry/#universal_mcp.tools.registry.ToolRegistry.load_tools","title":"load_tools  <code>async</code>","text":"<pre><code>load_tools(tools: list[str] | ToolConfig | None = None)\n</code></pre> <p>Load the tools to be used</p>"},{"location":"api/registry/#universal_mcp.tools.registry.ToolRegistry.export_tools","title":"export_tools  <code>async</code>","text":"<pre><code>export_tools(\n    tools: list[str] | ToolConfig | None = None,\n    format: ToolFormat = NATIVE,\n) -&gt; list[Any]\n</code></pre> <p>Export the loaded tools as in required format</p>"},{"location":"api/registry/#universal_mcp.tools.registry.ToolRegistry.call_tool","title":"call_tool  <code>async</code>","text":"<pre><code>call_tool(tool_name: str, tool_args: dict[str, Any]) -&gt; Any\n</code></pre> <p>Call a tool with the given name and arguments.</p>"},{"location":"api/registry/#universal_mcp.tools.registry.ToolRegistry.list_connected_apps","title":"list_connected_apps  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>list_connected_apps() -&gt; list[dict[str, Any]]\n</code></pre> <p>List all apps that the user has connected.</p>"},{"location":"api/registry/#localregistry","title":"LocalRegistry","text":"<p>               Bases: <code>ToolRegistry</code></p> <p>A local implementation of the tool registry.</p>"},{"location":"api/registry/#universal_mcp.tools.local_registry.LocalRegistry.__init__","title":"__init__","text":"<pre><code>__init__(output_dir: str = 'output')\n</code></pre> <p>Initialize the LocalRegistry.</p>"},{"location":"api/registry/#universal_mcp.tools.local_registry.LocalRegistry.list_all_apps","title":"list_all_apps  <code>async</code>","text":"<pre><code>list_all_apps() -&gt; list[dict[str, Any]]\n</code></pre> <p>Not implemented for LocalRegistry.</p>"},{"location":"api/registry/#universal_mcp.tools.local_registry.LocalRegistry.get_app_details","title":"get_app_details  <code>async</code>","text":"<pre><code>get_app_details(app_id: str) -&gt; dict[str, Any]\n</code></pre> <p>Not implemented for LocalRegistry.</p>"},{"location":"api/registry/#universal_mcp.tools.local_registry.LocalRegistry.search_apps","title":"search_apps  <code>async</code>","text":"<pre><code>search_apps(\n    query: str, limit: int = 2\n) -&gt; list[dict[str, Any]]\n</code></pre> <p>Not implemented for LocalRegistry.</p>"},{"location":"api/registry/#universal_mcp.tools.local_registry.LocalRegistry.list_tools","title":"list_tools  <code>async</code>","text":"<pre><code>list_tools(app_id: str) -&gt; list[dict[str, Any]]\n</code></pre> <p>Not implemented for LocalRegistry.</p>"},{"location":"api/registry/#universal_mcp.tools.local_registry.LocalRegistry.search_tools","title":"search_tools  <code>async</code>","text":"<pre><code>search_tools(\n    query: str, limit: int = 2, app_id: str | None = None\n) -&gt; list[dict[str, Any]]\n</code></pre> <p>Not implemented for LocalRegistry.</p>"},{"location":"api/registry/#universal_mcp.tools.local_registry.LocalRegistry.export_tools","title":"export_tools  <code>async</code>","text":"<pre><code>export_tools(\n    tools: list[str] | ToolConfig, format: ToolFormat\n) -&gt; list[Any]\n</code></pre> <p>Export given tools to the required format.</p>"},{"location":"api/registry/#universal_mcp.tools.local_registry.LocalRegistry.call_tool","title":"call_tool  <code>async</code>","text":"<pre><code>call_tool(tool_name: str, tool_args: dict[str, Any]) -&gt; Any\n</code></pre> <p>Call a tool and handle its output.</p>"},{"location":"api/registry/#universal_mcp.tools.local_registry.LocalRegistry.list_connected_apps","title":"list_connected_apps  <code>async</code>","text":"<pre><code>list_connected_apps() -&gt; list[dict[str, Any]]\n</code></pre> <p>Not implemented for LocalRegistry.</p>"},{"location":"api/registry/#usage-examples","title":"Usage Examples","text":""},{"location":"api/registry/#basic-registry-usage","title":"Basic Registry Usage","text":"<pre><code>from universal_mcp.tools import LocalRegistry, Tool\n\nregistry = LocalRegistry()\n\n# Register tool\ndef greet(name: str) -&gt; str:\n    \"\"\"Greet someone.\"\"\"\n    return f\"Hello, {name}!\"\n\ntool = Tool.from_function(greet)\nregistry.register(tool)\n\n# Get tool\ntool = registry.get(\"greet\")\n\n# List all tools\ntools = registry.list()\n\n# Check if tool exists\nif registry.exists(\"greet\"):\n    print(\"Tool exists\")\n\n# Remove tool\nregistry.unregister(\"greet\")\n</code></pre>"},{"location":"api/registry/#related-documentation","title":"Related Documentation","text":"<ul> <li>Tools API - Tool creation and management</li> <li>Servers API - Server using registry</li> </ul>"},{"location":"api/servers/","title":"Servers","text":""},{"location":"api/servers/#servers-api","title":"Servers API","text":"<p>Servers expose MCP protocol endpoints for AI agents to discover and call tools.</p>"},{"location":"api/servers/#baseserver","title":"BaseServer","text":"<p>               Bases: <code>FastMCP</code></p> <p>Base server for Universal MCP, manages ToolManager and tool invocation.</p>"},{"location":"api/servers/#localserver","title":"LocalServer","text":"<p>               Bases: <code>BaseServer</code></p> <p>Server that loads apps and store from local config.</p>"},{"location":"api/servers/#singlemcpserver","title":"SingleMCPServer","text":"<p>               Bases: <code>BaseServer</code></p> <p>Server for a single, pre-configured application.</p>"},{"location":"api/servers/#usage-examples","title":"Usage Examples","text":""},{"location":"api/servers/#localserver-with-yaml-config","title":"LocalServer with YAML Config","text":"<pre><code>from universal_mcp.servers import LocalServer\n\n# Create from config file\nserver = LocalServer.from_config(\"config.yaml\")\n\n# Run server (blocks)\nserver.run()\n</code></pre> <p>Example <code>config.yaml</code>: </p><pre><code>store:\n  type: keyring\n  service_name: universal-mcp\n\napplications:\n  - name: github\n    module: universal_mcp.applications.github\n    class_name: GitHubApp\n    integration:\n      type: oauth\n      client_id: ${GITHUB_CLIENT_ID}\n      client_secret: ${GITHUB_CLIENT_SECRET}\n      auth_url: https://github.com/login/oauth/authorize\n      token_url: https://github.com/login/oauth/access_token\n      scopes:\n        - repo\n        - user\n\n  - name: slack\n    module: myapp.slack\n    class_name: SlackApp\n    integration:\n      type: api_key\n      api_key_name: SLACK_BOT_TOKEN\n</code></pre><p></p>"},{"location":"api/servers/#singlemcpserver-programmatic","title":"SingleMCPServer (Programmatic)","text":"<pre><code>from universal_mcp.servers import SingleMCPServer\nfrom universal_mcp.applications import APIApplication\n\n# Create application\nclass MyApp(APIApplication):\n    def __init__(self):\n        super().__init__(name=\"myapp\")\n        self.base_url = \"https://api.example.com\"\n\n    def list_tools(self):\n        return [self.get_data]\n\n    def get_data(self, query: str) -&gt; dict:\n        \"\"\"Get data from API.\"\"\"\n        return self.get(f\"/data?q={query}\")\n\n# Wrap in server\napp = MyApp()\nserver = SingleMCPServer(app)\n\n# Run\nserver.run()\n</code></pre>"},{"location":"api/servers/#multiple-applications-with-localserver","title":"Multiple Applications with LocalServer","text":"<pre><code>from universal_mcp.servers import LocalServer\nfrom universal_mcp.stores import KeyringStore\nfrom universal_mcp.config import ServerConfig, AppConfig\n\n# Build config programmatically\nstore = KeyringStore(service_name=\"my-server\")\n\nconfig = ServerConfig(\n    store_config={\"type\": \"keyring\"},\n    applications=[\n        AppConfig(\n            name=\"github\",\n            module=\"my_apps.github\",\n            class_name=\"GitHubApp\",\n            integration={\n                \"type\": \"oauth\",\n                \"client_id\": \"...\",\n                # ...\n            }\n        ),\n        AppConfig(\n            name=\"slack\",\n            module=\"my_apps.slack\",\n            class_name=\"SlackApp\",\n            integration={\n                \"type\": \"api_key\",\n                \"api_key_name\": \"SLACK_TOKEN\"\n            }\n        )\n    ]\n)\n\n# Create server\nserver = LocalServer(config, store)\nserver.run()\n</code></pre>"},{"location":"api/servers/#running-server-in-background","title":"Running Server in Background","text":"<pre><code>import threading\n\nserver = SingleMCPServer(app)\n\n# Run in thread\nthread = threading.Thread(target=server.run, daemon=True)\nthread.start()\n\n# Server now running in background\n# Main thread can do other work\n</code></pre>"},{"location":"api/servers/#mcp-client-integration","title":"MCP Client Integration","text":"<p>From an MCP client (e.g., Claude Desktop):</p> <pre><code>{\n  \"mcpServers\": {\n    \"universal-mcp\": {\n      \"command\": \"universal_mcp\",\n      \"args\": [\"serve\", \"--config\", \"config.yaml\"],\n      \"env\": {\n        \"GITHUB_CLIENT_ID\": \"...\",\n        \"GITHUB_CLIENT_SECRET\": \"...\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"api/servers/#server-lifecycle","title":"Server Lifecycle","text":""},{"location":"api/servers/#startup","title":"Startup","text":"<pre><code>server = LocalServer.from_config(\"config.yaml\")\n# 1. Load config\n# 2. Create store\n# 3. Load applications\n# 4. Register tools\n# 5. Start FastMCP server\n\nserver.run()  # Blocks here, serving requests\n</code></pre>"},{"location":"api/servers/#graceful-shutdown","title":"Graceful Shutdown","text":"<pre><code>import signal\n\nserver = LocalServer.from_config(\"config.yaml\")\n\ndef signal_handler(sig, frame):\n    print(\"Shutting down...\")\n    server.shutdown()  # Clean shutdown\n    exit(0)\n\nsignal.signal(signal.SIGINT, signal_handler)\nsignal.signal(signal.SIGTERM, signal_handler)\n\nserver.run()\n</code></pre>"},{"location":"api/servers/#tool-discovery","title":"Tool Discovery","text":""},{"location":"api/servers/#list-available-tools","title":"List Available Tools","text":"<pre><code>server = LocalServer.from_config(\"config.yaml\")\n\n# List all tools\ntools = server.list_tools()\n\nfor tool in tools:\n    print(f\"{tool.name}: {tool.description}\")\n    print(f\"  Schema: {tool.inputSchema}\")\n</code></pre>"},{"location":"api/servers/#call-tool-directly","title":"Call Tool Directly","text":"<pre><code># Call tool (bypassing MCP protocol)\nresult = server.call_tool(\n    \"create_issue\",\n    {\n        \"repo\": \"owner/repo\",\n        \"title\": \"Bug report\",\n        \"body\": \"Found a bug...\"\n    }\n)\nprint(result)\n</code></pre>"},{"location":"api/servers/#configuration-options","title":"Configuration Options","text":""},{"location":"api/servers/#store-configuration","title":"Store Configuration","text":"<pre><code># Keyring (production)\nstore:\n  type: keyring\n  service_name: my-app\n\n# Environment variables\nstore:\n  type: environment\n\n# Memory (testing only)\nstore:\n  type: memory\n</code></pre>"},{"location":"api/servers/#application-configuration","title":"Application Configuration","text":"<pre><code>applications:\n  - name: myapp\n    module: path.to.module\n    class_name: MyAppClass\n\n    # Optional: pass kwargs to __init__\n    init_kwargs:\n      timeout: 30\n      retry: true\n\n    # Integration (optional)\n    integration:\n      type: api_key\n      api_key_name: MY_API_KEY\n</code></pre>"},{"location":"api/servers/#server-options","title":"Server Options","text":"<pre><code>server:\n  # Server name in MCP\n  name: \"My MCP Server\"\n\n  # Server version\n  version: \"1.0.0\"\n\n  # Enable debug logging\n  debug: true\n\n  # Custom transport options\n  transport:\n    buffer_size: 8192\n</code></pre>"},{"location":"api/servers/#testing","title":"Testing","text":""},{"location":"api/servers/#test-server-with-mock-application","title":"Test Server with Mock Application","text":"<pre><code>from universal_mcp.servers import SingleMCPServer\nfrom universal_mcp.applications import BaseApplication\n\nclass MockApp(BaseApplication):\n    def list_tools(self):\n        return [self.test_tool]\n\n    def test_tool(self, input: str) -&gt; str:\n        \"\"\"Test tool.\"\"\"\n        return f\"Echo: {input}\"\n\n# Test\nserver = SingleMCPServer(MockApp(\"test\"))\nresult = server.call_tool(\"test_tool\", {\"input\": \"hello\"})\nassert result == \"Echo: hello\"\n</code></pre>"},{"location":"api/servers/#integration-tests","title":"Integration Tests","text":"<pre><code>import pytest\nfrom universal_mcp.servers import LocalServer\n\n@pytest.fixture\ndef server():\n    return LocalServer.from_config(\"test_config.yaml\")\n\ndef test_list_tools(server):\n    tools = server.list_tools()\n    assert len(tools) &gt; 0\n    assert any(t.name == \"expected_tool\" for t in tools)\n\ndef test_call_tool(server):\n    result = server.call_tool(\"test_tool\", {\"arg\": \"value\"})\n    assert result is not None\n</code></pre>"},{"location":"api/servers/#error-handling","title":"Error Handling","text":""},{"location":"api/servers/#application-load-errors","title":"Application Load Errors","text":"<pre><code>try:\n    server = LocalServer.from_config(\"config.yaml\")\nexcept ImportError as e:\n    print(f\"Failed to import application: {e}\")\nexcept Exception as e:\n    print(f\"Configuration error: {e}\")\n</code></pre>"},{"location":"api/servers/#tool-call-errors","title":"Tool Call Errors","text":"<pre><code>from universal_mcp.exceptions import ToolNotFoundError, NotAuthorizedError\n\ntry:\n    result = server.call_tool(\"my_tool\", {\"arg\": \"value\"})\nexcept ToolNotFoundError:\n    print(\"Tool not found\")\nexcept NotAuthorizedError:\n    print(\"Authentication required\")\nexcept Exception as e:\n    print(f\"Tool execution error: {e}\")\n</code></pre>"},{"location":"api/servers/#best-practices","title":"Best Practices","text":""},{"location":"api/servers/#1-use-yaml-config-for-production","title":"1. Use YAML Config for Production","text":"<pre><code># Good - configuration as code\nserver = LocalServer.from_config(\"config.yaml\")\n\n# Avoid - hardcoded configuration\nserver = LocalServer(hardcoded_config)\n</code></pre>"},{"location":"api/servers/#2-environment-variables-for-secrets","title":"2. Environment Variables for Secrets","text":"<pre><code># Good\nintegration:\n  client_id: ${GITHUB_CLIENT_ID}\n  client_secret: ${GITHUB_CLIENT_SECRET}\n\n# Bad - secrets in config file\nintegration:\n  client_id: \"abc123\"\n  client_secret: \"secret456\"\n</code></pre>"},{"location":"api/servers/#3-structured-logging","title":"3. Structured Logging","text":"<pre><code>import logging\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n\nserver = LocalServer.from_config(\"config.yaml\")\nserver.run()\n</code></pre>"},{"location":"api/servers/#4-health-checks","title":"4. Health Checks","text":"<pre><code>def check_server_health(server):\n    \"\"\"Check if server can list tools.\"\"\"\n    try:\n        tools = server.list_tools()\n        return len(tools) &gt; 0\n    except Exception:\n        return False\n\nif not check_server_health(server):\n    print(\"Server health check failed!\")\n</code></pre>"},{"location":"api/servers/#related-documentation","title":"Related Documentation","text":"<ul> <li>Architecture: Server Initialization - Startup flow</li> <li>Configuration API - Config schema</li> <li>Applications API - Creating applications</li> </ul>"},{"location":"api/stores/","title":"Stores","text":""},{"location":"api/stores/#stores-api","title":"Stores API","text":"<p>Stores provide secure credential storage backends.</p>"},{"location":"api/stores/#basestore","title":"BaseStore","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class defining a common interface for credential stores.</p> <p>This class outlines the essential methods (<code>get</code>, <code>set</code>, <code>delete</code>) that all concrete store implementations must provide. It ensures a consistent API for managing sensitive data across various storage backends like in-memory dictionaries, environment variables, or system keyrings.</p>"},{"location":"api/stores/#universal_mcp.stores.store.BaseStore.get","title":"get  <code>abstractmethod</code>","text":"<pre><code>get(key: str) -&gt; Any\n</code></pre> <p>Retrieve data from the store.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key for which to retrieve the value.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The value associated with the key.</p> <p>Raises:</p> Type Description <code>KeyNotFoundError</code> <p>If the specified key is not found in the store.</p> <code>StoreError</code> <p>For other store-related operational errors.</p>"},{"location":"api/stores/#universal_mcp.stores.store.BaseStore.set","title":"set  <code>abstractmethod</code>","text":"<pre><code>set(key: str, value: Any) -&gt; None\n</code></pre> <p>Set or update a key-value pair in the store.</p> <p>If the key already exists, its value should be updated. If the key does not exist, it should be created.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to set or update.</p> required <code>value</code> <code>Any</code> <p>The value to associate with the key.</p> required <p>Raises:</p> Type Description <code>StoreError</code> <p>For store-related operational errors (e.g., write failures).</p>"},{"location":"api/stores/#universal_mcp.stores.store.BaseStore.delete","title":"delete  <code>abstractmethod</code>","text":"<pre><code>delete(key: str) -&gt; None\n</code></pre> <p>Delete a key-value pair from the store.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to delete.</p> required <p>Raises:</p> Type Description <code>KeyNotFoundError</code> <p>If the specified key is not found in the store.</p> <code>StoreError</code> <p>For other store-related operational errors (e.g., delete failures).</p>"},{"location":"api/stores/#universal_mcp.stores.store.BaseStore.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Returns an unambiguous string representation of the store instance.</p>"},{"location":"api/stores/#universal_mcp.stores.store.BaseStore.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Returns a human-readable string representation of the store instance.</p>"},{"location":"api/stores/#memorystore","title":"MemoryStore","text":"<p>               Bases: <code>BaseStore</code></p> <p>In-memory credential and data store using a Python dictionary.</p> <p>This store implementation holds all data within a dictionary in memory. It is simple and fast but is not persistent; all stored data will be lost when the application process terminates. Primarily useful for testing, transient data, or development scenarios where persistence is not required.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>dict[str, Any]</code> <p>The dictionary holding the stored key-value pairs.</p>"},{"location":"api/stores/#universal_mcp.stores.store.MemoryStore.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> <p>Initializes the MemoryStore with an empty dictionary.</p>"},{"location":"api/stores/#universal_mcp.stores.store.MemoryStore.get","title":"get","text":"<pre><code>get(key: str) -&gt; Any\n</code></pre> <p>Retrieves the value associated with the given key from the in-memory store.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key whose value is to be retrieved.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The value associated with the key.</p> <p>Raises:</p> Type Description <code>KeyNotFoundError</code> <p>If the key is not found in the store.</p>"},{"location":"api/stores/#universal_mcp.stores.store.MemoryStore.set","title":"set","text":"<pre><code>set(key: str, value: Any) -&gt; None\n</code></pre> <p>Sets or updates the value for a given key in the in-memory store.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to set or update.</p> required <code>value</code> <code>Any</code> <p>The value to associate with the key.</p> required"},{"location":"api/stores/#universal_mcp.stores.store.MemoryStore.delete","title":"delete","text":"<pre><code>delete(key: str) -&gt; None\n</code></pre> <p>Deletes a key-value pair from the in-memory store.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to delete.</p> required <p>Raises:</p> Type Description <code>KeyNotFoundError</code> <p>If the key is not found in the store.</p>"},{"location":"api/stores/#environmentstore","title":"EnvironmentStore","text":"<p>               Bases: <code>BaseStore</code></p> <p>Credential and data store using operating system environment variables.</p> <p>This store implementation interacts directly with environment variables using <code>os.getenv</code>, <code>os.environ[]</code>, and <code>del os.environ[]</code>. Changes made via <code>set</code> or <code>delete</code> will affect the environment of the current Python process and potentially its subprocesses, but typically do not persist beyond the life of the parent shell or system session unless explicitly managed externally.</p>"},{"location":"api/stores/#universal_mcp.stores.store.EnvironmentStore.get","title":"get","text":"<pre><code>get(key: str) -&gt; Any\n</code></pre> <p>Retrieves the value of an environment variable.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the environment variable.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The value of the environment variable as a string.</p> <p>Raises:</p> Type Description <code>KeyNotFoundError</code> <p>If the environment variable is not set.</p>"},{"location":"api/stores/#universal_mcp.stores.store.EnvironmentStore.set","title":"set","text":"<pre><code>set(key: str, value: Any) -&gt; None\n</code></pre> <p>Sets an environment variable in the current process.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the environment variable.</p> required <code>value</code> <code>Any</code> <p>The value to set for the environment variable.          It will be converted to a string.</p> required"},{"location":"api/stores/#universal_mcp.stores.store.EnvironmentStore.delete","title":"delete","text":"<pre><code>delete(key: str) -&gt; None\n</code></pre> <p>Deletes an environment variable from the current process.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the environment variable to delete.</p> required <p>Raises:</p> Type Description <code>KeyNotFoundError</code> <p>If the environment variable is not set.</p>"},{"location":"api/stores/#keyringstore","title":"KeyringStore","text":"<p>               Bases: <code>BaseStore</code></p> <p>Secure credential store using the system's keyring service.</p> <p>This store leverages the <code>keyring</code> library to interact with the operating system's native secure credential management system (e.g., macOS Keychain, Windows Credential Manager, Freedesktop Secret Service / KWallet on Linux). It is suitable for storing sensitive data like API keys and passwords persistently and securely.</p> <p>Attributes:</p> Name Type Description <code>app_name</code> <code>str</code> <p>The service name under which credentials are stored             in the system keyring. This helps namespace credentials             for different applications.</p>"},{"location":"api/stores/#universal_mcp.stores.store.KeyringStore.__init__","title":"__init__","text":"<pre><code>__init__(app_name: str = 'universal_mcp')\n</code></pre> <p>Initializes the KeyringStore.</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>The service name to use when interacting with the system keyring. This helps to namespace credentials. Defaults to \"universal_mcp\".</p> <code>'universal_mcp'</code>"},{"location":"api/stores/#universal_mcp.stores.store.KeyringStore.get","title":"get","text":"<pre><code>get(key: str) -&gt; str\n</code></pre> <p>Retrieves a secret (password) from the system keyring.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The username or key associated with the secret.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The stored secret string.</p> <p>Raises:</p> Type Description <code>KeyNotFoundError</code> <p>If the key is not found in the keyring under               <code>self.app_name</code>, or if <code>keyring</code> library errors occur.</p>"},{"location":"api/stores/#universal_mcp.stores.store.KeyringStore.set","title":"set","text":"<pre><code>set(key: str, value: Any) -&gt; None\n</code></pre> <p>Stores a secret (password) in the system keyring.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The username or key to associate with the secret.</p> required <code>value</code> <code>Any</code> <p>The secret to store. It will be converted to a string.</p> required <p>Raises:</p> Type Description <code>StoreError</code> <p>If storing the secret in the keyring fails.</p>"},{"location":"api/stores/#universal_mcp.stores.store.KeyringStore.delete","title":"delete","text":"<pre><code>delete(key: str) -&gt; None\n</code></pre> <p>Deletes a secret (password) from the system keyring.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The username or key of the secret to delete.</p> required <p>Raises:</p> Type Description <code>KeyNotFoundError</code> <p>If the key is not found in the keyring (note: some               keyring backends might not raise an error for               non-existent keys, this tries to standardize).</p> <code>StoreError</code> <p>If deleting the secret from the keyring fails for other         reasons.</p>"},{"location":"api/stores/#usage-examples","title":"Usage Examples","text":""},{"location":"api/stores/#memorystore-testing","title":"MemoryStore (Testing)","text":"<pre><code>from universal_mcp.stores import MemoryStore\n\nstore = MemoryStore()\n\n# Set value\nstore.set(\"api_key\", \"sk_test_123\")\n\n# Get value\napi_key = store.get(\"api_key\")\nprint(api_key)  # \"sk_test_123\"\n\n# List keys\nkeys = store.list_keys()\nprint(keys)  # [\"api_key\"]\n\n# Delete\nstore.delete(\"api_key\")\n\n# Clear all\nstore.clear()\n</code></pre>"},{"location":"api/stores/#environmentstore_1","title":"EnvironmentStore","text":"<pre><code>from universal_mcp.stores import EnvironmentStore\nimport os\n\nstore = EnvironmentStore()\n\n# Set (writes to os.environ)\nstore.set(\"API_KEY\", \"sk_live_456\")\n\n# Get\napi_key = store.get(\"API_KEY\")\nprint(api_key)  # \"sk_live_456\"\n\n# Also accessible via os.environ\nprint(os.environ[\"API_KEY\"])  # \"sk_live_456\"\n\n# List all env vars\nkeys = store.list_keys()\nprint(\"HOME\" in keys)  # True\n</code></pre>"},{"location":"api/stores/#keyringstore-production","title":"KeyringStore (Production)","text":"<pre><code>from universal_mcp.stores import KeyringStore\n\n# Create with service name\nstore = KeyringStore(service_name=\"my-app\")\n\n# Set secure credential\nstore.set(\"github_token\", \"ghp_abc123...\")\n\n# Get credential\n# (requires OS authentication on first access)\ntoken = store.get(\"github_token\")\n\n# List keys for this service\nkeys = store.list_keys()\nprint(keys)  # [\"github_token\"]\n\n# Delete\nstore.delete(\"github_token\")\n</code></pre>"},{"location":"api/stores/#store-factory-pattern","title":"Store Factory Pattern","text":"<pre><code>from universal_mcp.stores import create_store\n\n# Create from config\nstore = create_store({\n    \"type\": \"keyring\",\n    \"service_name\": \"my-app\"\n})\n\n# Or\nstore = create_store({\"type\": \"memory\"})\n\n# Or\nstore = create_store({\"type\": \"environment\"})\n</code></pre>"},{"location":"api/stores/#comparison-matrix","title":"Comparison Matrix","text":"Feature MemoryStore EnvironmentStore KeyringStore Persistence No (lost on exit) No (per-session) Yes (OS keyring) Security Low Medium High Setup None None OS keyring Performance Fastest Fast Slower (OS calls) Cross-process No Yes (same session) Yes Best For Testing CI/CD, containers Production"},{"location":"api/stores/#security-considerations","title":"Security Considerations","text":""},{"location":"api/stores/#memorystore_1","title":"MemoryStore","text":"<pre><code># In-process only\nstore = MemoryStore()\nstore.set(\"secret\", \"sensitive_data\")\n\n# Lost on process exit\n# Visible in memory dumps\n# Not shared across processes\n</code></pre> <p>Use for: Unit tests, temporary data</p>"},{"location":"api/stores/#environmentstore_2","title":"EnvironmentStore","text":"<pre><code># Accessible in process environment\nstore = EnvironmentStore()\nstore.set(\"SECRET\", \"sensitive_data\")\n\n# Visible to:\n# - Child processes\n# - Process inspection tools (ps env)\n# - Core dumps\n\nimport os\nprint(os.environ[\"SECRET\"])  # Accessible\n</code></pre> <p>Use for: Containerized apps, CI/CD pipelines</p>"},{"location":"api/stores/#keyringstore_1","title":"KeyringStore","text":"<pre><code># OS-level encryption\nstore = KeyringStore(service_name=\"my-app\")\nstore.set(\"secret\", \"sensitive_data\")\n\n# Encrypted at rest\n# Requires OS authentication\n# Shared across user's apps\n</code></pre> <p>Use for: Desktop applications, production servers</p>"},{"location":"api/stores/#platform-specific-behavior","title":"Platform-Specific Behavior","text":""},{"location":"api/stores/#macos","title":"macOS","text":"<pre><code>store = KeyringStore(service_name=\"my-app\")\nstore.set(\"key\", \"value\")\n\n# Stored in Keychain\n# Accessible via Keychain Access.app\n# Backed up with user's iCloud Keychain\n</code></pre>"},{"location":"api/stores/#windows","title":"Windows","text":"<pre><code>store = KeyringStore(service_name=\"my-app\")\nstore.set(\"key\", \"value\")\n\n# Stored in Windows Credential Manager\n# Accessible via Control Panel \u2192 Credential Manager\n# Backed up with user profile\n</code></pre>"},{"location":"api/stores/#linux","title":"Linux","text":"<pre><code>store = KeyringStore(service_name=\"my-app\")\nstore.set(\"key\", \"value\")\n\n# Uses Secret Service API (GNOME Keyring, KWallet)\n# Or falls back to encrypted file\n</code></pre>"},{"location":"api/stores/#error-handling","title":"Error Handling","text":""},{"location":"api/stores/#key-not-found","title":"Key Not Found","text":"<pre><code>from universal_mcp.exceptions import KeyNotFoundError\n\ntry:\n    value = store.get(\"nonexistent_key\")\nexcept KeyNotFoundError as e:\n    print(f\"Key not found: {e.key}\")\n    # Set default or prompt user\n    store.set(e.key, \"default_value\")\n</code></pre>"},{"location":"api/stores/#keyring-access-denied","title":"Keyring Access Denied","text":"<pre><code>try:\n    store = KeyringStore(service_name=\"my-app\")\n    value = store.get(\"key\")\nexcept Exception as e:\n    print(f\"Keyring access failed: {e}\")\n    # Fall back to environment store\n    store = EnvironmentStore()\n</code></pre>"},{"location":"api/stores/#complex-data-types","title":"Complex Data Types","text":"<p>Stores handle JSON serialization automatically:</p> <pre><code>store = KeyringStore(service_name=\"my-app\")\n\n# Store dict\nstore.set(\"config\", {\n    \"api_url\": \"https://api.example.com\",\n    \"timeout\": 30,\n    \"retries\": 3\n})\n\n# Retrieve dict\nconfig = store.get(\"config\")\nprint(config[\"api_url\"])  # Works!\n\n# Store list\nstore.set(\"tags\", [\"python\", \"mcp\", \"api\"])\ntags = store.get(\"tags\")\n</code></pre>"},{"location":"api/stores/#migration-between-stores","title":"Migration Between Stores","text":"<pre><code>def migrate_store(old_store, new_store):\n    \"\"\"Migrate all keys from old store to new store.\"\"\"\n    for key in old_store.list_keys():\n        try:\n            value = old_store.get(key)\n            new_store.set(key, value)\n            print(f\"Migrated: {key}\")\n        except Exception as e:\n            print(f\"Failed to migrate {key}: {e}\")\n\n# Example: Memory to Keyring\nmemory_store = MemoryStore()\nmemory_store.set(\"key1\", \"value1\")\nmemory_store.set(\"key2\", \"value2\")\n\nkeyring_store = KeyringStore(service_name=\"my-app\")\nmigrate_store(memory_store, keyring_store)\n</code></pre>"},{"location":"api/stores/#testing","title":"Testing","text":""},{"location":"api/stores/#mock-store-for-tests","title":"Mock Store for Tests","text":"<pre><code>from unittest.mock import MagicMock\n\ndef create_mock_store():\n    store = MagicMock()\n    store._data = {}\n\n    def mock_get(key):\n        return store._data.get(key)\n\n    def mock_set(key, value):\n        store._data[key] = value\n\n    store.get.side_effect = mock_get\n    store.set.side_effect = mock_set\n    return store\n\n# Use in tests\nstore = create_mock_store()\n</code></pre>"},{"location":"api/stores/#in-memory-store-for-integration-tests","title":"In-Memory Store for Integration Tests","text":"<pre><code>import pytest\nfrom universal_mcp.stores import MemoryStore\n\n@pytest.fixture\ndef store():\n    \"\"\"Provide clean store for each test.\"\"\"\n    return MemoryStore()\n\ndef test_integration_flow(store):\n    integration = ApiKeyIntegration(\"test\", store)\n    store.set(\"API_KEY\", \"test_key\")\n    creds = integration.get_credentials()\n    assert creds[\"api_key\"] == \"test_key\"\n</code></pre>"},{"location":"api/stores/#best-practices","title":"Best Practices","text":""},{"location":"api/stores/#1-choose-right-store-for-environment","title":"1. Choose Right Store for Environment","text":"<pre><code># Development\nif os.getenv(\"ENV\") == \"development\":\n    store = MemoryStore()\n\n# Production\nelif os.getenv(\"ENV\") == \"production\":\n    store = KeyringStore(service_name=\"my-app\")\n\n# CI/CD\nelif os.getenv(\"CI\"):\n    store = EnvironmentStore()\n</code></pre>"},{"location":"api/stores/#2-namespace-keys","title":"2. Namespace Keys","text":"<pre><code># Good - namespaced keys\nstore.set(\"github.api_key\", \"...\")\nstore.set(\"github.oauth_token\", \"...\")\nstore.set(\"slack.bot_token\", \"...\")\n\n# Bad - collision risk\nstore.set(\"api_key\", \"...\")  # Which API?\nstore.set(\"token\", \"...\")  # Which service?\n</code></pre>"},{"location":"api/stores/#3-handle-missing-keys-gracefully","title":"3. Handle Missing Keys Gracefully","text":"<pre><code>def get_or_prompt(store, key):\n    try:\n        return store.get(key)\n    except KeyNotFoundError:\n        value = input(f\"Please enter {key}: \")\n        store.set(key, value)\n        return value\n</code></pre>"},{"location":"api/stores/#4-clear-sensitive-data","title":"4. Clear Sensitive Data","text":"<pre><code># After temporary use\nstore.set(\"temp_token\", \"...\")\n# ... use token ...\nstore.delete(\"temp_token\")  # Clean up\n\n# Or clear all on logout\ndef logout(store):\n    store.clear()\n</code></pre>"},{"location":"api/stores/#related-documentation","title":"Related Documentation","text":"<ul> <li>Architecture: Authentication Flow - How stores are used</li> <li>Integrations API - Integrations using stores</li> <li>Configuration API - Store configuration</li> </ul>"},{"location":"api/tools/","title":"Tools","text":""},{"location":"api/tools/#tools-api","title":"Tools API","text":"<p>The tools system converts Python functions into AI-callable tools with JSON schemas.</p>"},{"location":"api/tools/#tool","title":"Tool","text":"<p>               Bases: <code>BaseModel</code></p> <p>Internal tool registration info.</p>"},{"location":"api/tools/#universal_mcp.tools.tools.Tool.from_function","title":"from_function  <code>classmethod</code>","text":"<pre><code>from_function(\n    fn: Callable[..., Any], name: str | None = None\n) -&gt; Tool\n</code></pre> <p>Create a Tool from a function.</p>"},{"location":"api/tools/#universal_mcp.tools.tools.Tool.run","title":"run  <code>async</code>","text":"<pre><code>run(\n    arguments: dict[str, Any],\n    context: dict[str, Any] | None = None,\n) -&gt; Any\n</code></pre> <p>Run the tool with arguments.</p>"},{"location":"api/tools/#toolmanager","title":"ToolManager","text":"<p>Manages tools</p> <p>This class provides functionality for registering, managing, and executing tools. It supports multiple tool formats and provides filtering capabilities based on names and tags. Tools are organized by their source application for better management.</p>"},{"location":"api/tools/#universal_mcp.tools.manager.ToolManager.__init__","title":"__init__","text":"<pre><code>__init__(\n    warn_on_duplicate_tools: bool = True,\n    default_format: ToolFormat = MCP,\n)\n</code></pre> <p>Initialize the ToolManager.</p> <p>Parameters:</p> Name Type Description Default <code>warn_on_duplicate_tools</code> <code>bool</code> <p>Whether to warn when duplicate tool names are detected.</p> <code>True</code>"},{"location":"api/tools/#universal_mcp.tools.manager.ToolManager.get_tool","title":"get_tool","text":"<pre><code>get_tool(name: str) -&gt; Tool | None\n</code></pre> <p>Get tool by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the tool to retrieve.</p> required <p>Returns:</p> Type Description <code>Tool | None</code> <p>The Tool instance if found, None otherwise.</p>"},{"location":"api/tools/#universal_mcp.tools.manager.ToolManager.get_tools","title":"get_tools","text":"<pre><code>get_tools(\n    tool_names: list[str] | None = None,\n    tags: list[str] | None = None,\n) -&gt; list[Tool]\n</code></pre> <p>Get a filtered list of registered tools.</p> <p>Parameters:</p> Name Type Description Default <code>tags</code> <code>list[str] | None</code> <p>Optional list of tags to filter tools by.</p> <code>None</code> <code>tool_names</code> <code>list[str] | None</code> <p>Optional list of tool names to filter by.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Tool]</code> <p>A list of Tool instances.</p>"},{"location":"api/tools/#universal_mcp.tools.manager.ToolManager.add_tool","title":"add_tool","text":"<pre><code>add_tool(\n    fn: Callable[..., Any] | Tool, name: str | None = None\n) -&gt; Tool\n</code></pre> <p>Add a tool to the manager.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any] | Tool</code> <p>The tool function or Tool instance to add.</p> required <code>name</code> <code>str | None</code> <p>Optional name override for the tool.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tool</code> <p>The registered Tool instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tool name is invalid.</p>"},{"location":"api/tools/#universal_mcp.tools.manager.ToolManager.register_tools","title":"register_tools","text":"<pre><code>register_tools(tools: list[Tool]) -&gt; None\n</code></pre> <p>Register a list of tools.</p> <p>Parameters:</p> Name Type Description Default <code>tools</code> <code>list[Tool]</code> <p>List of tools to register.</p> required <code>app_name</code> <p>Application name to group the tools under.</p> required"},{"location":"api/tools/#universal_mcp.tools.manager.ToolManager.remove_tool","title":"remove_tool","text":"<pre><code>remove_tool(name: str) -&gt; bool\n</code></pre> <p>Remove a tool by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the tool to remove.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the tool was removed, False if it didn't exist.</p>"},{"location":"api/tools/#universal_mcp.tools.manager.ToolManager.clear_tools","title":"clear_tools","text":"<pre><code>clear_tools() -&gt; None\n</code></pre> <p>Remove all registered tools.</p>"},{"location":"api/tools/#universal_mcp.tools.manager.ToolManager.register_tools_from_app","title":"register_tools_from_app","text":"<pre><code>register_tools_from_app(\n    app: BaseApplication,\n    tool_names: list[str] | None = None,\n    tags: list[str] | None = None,\n) -&gt; None\n</code></pre> <p>Register tools from an application.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>BaseApplication</code> <p>The application to register tools from.</p> required <code>tool_names</code> <code>list[str] | None</code> <p>Optional list of specific tool names to register.</p> <code>None</code> <code>tags</code> <code>list[str] | None</code> <p>Optional list of tags to filter tools by.</p> <code>None</code>"},{"location":"api/tools/#funcmetadata","title":"FuncMetadata","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/tools/#usage-examples","title":"Usage Examples","text":""},{"location":"api/tools/#creating-tools-from-functions","title":"Creating Tools from Functions","text":"<pre><code>from universal_mcp.tools import Tool\n\ndef greet(name: str, greeting: str = \"Hello\") -&gt; str:\n    \"\"\"Greet someone by name.\n\n    Args:\n        name: Person's name\n        greeting: Greeting word (default: Hello)\n\n    Returns:\n        Greeting message\n    \"\"\"\n    return f\"{greeting}, {name}!\"\n\n# Create tool from function\ntool = Tool.from_function(greet)\n\nprint(tool.name)  # \"greet\"\nprint(tool.description)  # \"Greet someone by name\"\nprint(tool.inputSchema)\n# {\n#   \"type\": \"object\",\n#   \"properties\": {\n#     \"name\": {\"type\": \"string\", \"description\": \"Person's name\"},\n#     \"greeting\": {\n#       \"type\": \"string\",\n#       \"description\": \"Greeting word (default: Hello)\",\n#       \"default\": \"Hello\"\n#     }\n#   },\n#   \"required\": [\"name\"]\n# }\n\n# Execute tool\nresult = tool.execute(name=\"Alice\", greeting=\"Hi\")\nprint(result)  # \"Hi, Alice!\"\n</code></pre>"},{"location":"api/tools/#using-toolmanager","title":"Using ToolManager","text":"<pre><code>from universal_mcp.tools import ToolManager, Tool\n\nmanager = ToolManager()\n\n# Add tools\ndef add(a: int, b: int) -&gt; int:\n    \"\"\"Add two numbers.\"\"\"\n    return a + b\n\ndef multiply(a: int, b: int) -&gt; int:\n    \"\"\"Multiply two numbers.\"\"\"\n    return a * b\n\nmanager.add_tool(Tool.from_function(add))\nmanager.add_tool(Tool.from_function(multiply))\n\n# List tools\ntools = manager.list_tools()\nprint([t.name for t in tools])  # [\"add\", \"multiply\"]\n\n# Get specific tool\ntool = manager.get_tool(\"add\")\n\n# Call tool by name\nresult = manager.call_tool(\"add\", {\"a\": 5, \"b\": 3})\nprint(result)  # 8\n</code></pre>"},{"location":"api/tools/#complex-type-examples","title":"Complex Type Examples","text":""},{"location":"api/tools/#lists-and-dicts","title":"Lists and Dicts","text":"<pre><code>def process_items(\n    items: list[str],\n    config: dict[str, any] | None = None\n) -&gt; dict:\n    \"\"\"Process a list of items.\n\n    Args:\n        items: List of item names\n        config: Optional configuration dict\n\n    Returns:\n        Processing results\n    \"\"\"\n    # ...\n</code></pre> <p>Generated schema: </p><pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"items\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"}\n    },\n    \"config\": {\n      \"type\": \"object\"\n    }\n  },\n  \"required\": [\"items\"]\n}\n</code></pre><p></p>"},{"location":"api/tools/#literal-types-enums","title":"Literal Types (Enums)","text":"<pre><code>from typing import Literal\n\ndef set_log_level(\n    level: Literal[\"debug\", \"info\", \"warning\", \"error\"]\n) -&gt; None:\n    \"\"\"Set logging level.\n\n    Args:\n        level: Log level to set\n    \"\"\"\n    # ...\n</code></pre> <p>Generated schema: </p><pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"level\": {\n      \"type\": \"string\",\n      \"enum\": [\"debug\", \"info\", \"warning\", \"error\"]\n    }\n  },\n  \"required\": [\"level\"]\n}\n</code></pre><p></p>"},{"location":"api/tools/#union-types","title":"Union Types","text":"<pre><code>def search(query: str | int) -&gt; list[dict]:\n    \"\"\"Search by query (text or ID).\n\n    Args:\n        query: Search query (string) or ID (integer)\n\n    Returns:\n        Search results\n    \"\"\"\n    # ...\n</code></pre> <p>Generated schema: </p><pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"query\": {\n      \"anyOf\": [\n        {\"type\": \"string\"},\n        {\"type\": \"integer\"}\n      ]\n    }\n  },\n  \"required\": [\"query\"]\n}\n</code></pre><p></p>"},{"location":"api/tools/#funcmetadata-examples","title":"FuncMetadata Examples","text":"<pre><code>from universal_mcp.tools import FuncMetadata\n\ndef example_func(arg1: str, arg2: int = 10) -&gt; dict:\n    \"\"\"Example function.\n\n    Args:\n        arg1: First argument\n        arg2: Second argument\n\n    Returns:\n        Result dictionary\n    \"\"\"\n    pass\n\n# Extract metadata\nmetadata = FuncMetadata.extract_from_function(example_func)\n\nprint(metadata.name)  # \"example_func\"\nprint(metadata.description)  # \"Example function\"\nprint(metadata.parameters)\n# {\n#   \"arg1\": {\n#     \"type\": \"string\",\n#     \"description\": \"First argument\",\n#     \"required\": True\n#   },\n#   \"arg2\": {\n#     \"type\": \"integer\",\n#     \"description\": \"Second argument\",\n#     \"default\": 10,\n#     \"required\": False\n#   }\n# }\n</code></pre>"},{"location":"api/tools/#docstring-formats","title":"Docstring Formats","text":""},{"location":"api/tools/#google-style-recommended","title":"Google Style (Recommended)","text":"<pre><code>def function(arg1: str, arg2: int) -&gt; bool:\n    \"\"\"Short description.\n\n    Longer description if needed.\n\n    Args:\n        arg1: Description of arg1\n        arg2: Description of arg2\n\n    Returns:\n        Description of return value\n\n    Raises:\n        ValueError: When something is wrong\n    \"\"\"\n</code></pre>"},{"location":"api/tools/#numpy-style","title":"NumPy Style","text":"<pre><code>def function(arg1: str, arg2: int) -&gt; bool:\n    \"\"\"Short description.\n\n    Longer description if needed.\n\n    Parameters\n    ----------\n    arg1 : str\n        Description of arg1\n    arg2 : int\n        Description of arg2\n\n    Returns\n    -------\n    bool\n        Description of return value\n    \"\"\"\n</code></pre>"},{"location":"api/tools/#restructuredtext-style","title":"reStructuredText Style","text":"<pre><code>def function(arg1: str, arg2: int) -&gt; bool:\n    \"\"\"Short description.\n\n    Longer description if needed.\n\n    :param arg1: Description of arg1\n    :param arg2: Description of arg2\n    :return: Description of return value\n    :rtype: bool\n    \"\"\"\n</code></pre>"},{"location":"api/tools/#tool-validation","title":"Tool Validation","text":"<p>Tools validate arguments against their schema:</p> <pre><code>tool = Tool.from_function(greet)\n\n# Valid call\nresult = tool.execute(name=\"Alice\")  # OK\n\n# Invalid: missing required argument\ntry:\n    tool.execute(greeting=\"Hi\")  # Missing 'name'\nexcept Exception as e:\n    print(e)  # Validation error\n\n# Invalid: wrong type\ntry:\n    tool.execute(name=123)  # name should be string\nexcept Exception as e:\n    print(e)  # Type error\n</code></pre>"},{"location":"api/tools/#advanced-custom-tool-creation","title":"Advanced: Custom Tool Creation","text":"<pre><code>from universal_mcp.tools import Tool\n\n# Create tool manually (without function)\ntool = Tool(\n    name=\"custom_tool\",\n    description=\"A custom tool\",\n    inputSchema={\n        \"type\": \"object\",\n        \"properties\": {\n            \"input\": {\"type\": \"string\"}\n        },\n        \"required\": [\"input\"]\n    },\n    fn=lambda input: f\"Processed: {input}\"\n)\n\nresult = tool.execute(input=\"test\")\nprint(result)  # \"Processed: test\"\n</code></pre>"},{"location":"api/tools/#best-practices","title":"Best Practices","text":""},{"location":"api/tools/#1-write-clear-docstrings","title":"1. Write Clear Docstrings","text":"<pre><code># Good\ndef create_user(name: str, email: str) -&gt; dict:\n    \"\"\"Create a new user account.\n\n    Args:\n        name: Full name (2-50 characters)\n        email: Valid email address\n\n    Returns:\n        Created user object with id and created_at timestamp\n    \"\"\"\n\n# Bad\ndef create_user(name: str, email: str) -&gt; dict:\n    \"\"\"Creates user.\"\"\"  # Too brief, no details\n</code></pre>"},{"location":"api/tools/#2-use-type-hints","title":"2. Use Type Hints","text":"<pre><code># Good\ndef search(\n    query: str,\n    limit: int = 10,\n    offset: int = 0\n) -&gt; list[dict]:\n\n# Bad\ndef search(query, limit=10, offset=0):\n    # No schema can be generated\n</code></pre>"},{"location":"api/tools/#3-use-literal-for-enums","title":"3. Use Literal for Enums","text":"<pre><code># Good - generates proper enum\nfrom typing import Literal\n\ndef sort(\n    order: Literal[\"asc\", \"desc\"]\n) -&gt; list:\n\n# Bad - accepts any string\ndef sort(order: str) -&gt; list:\n</code></pre>"},{"location":"api/tools/#4-document-exceptions","title":"4. Document Exceptions","text":"<pre><code>def divide(a: float, b: float) -&gt; float:\n    \"\"\"Divide two numbers.\n\n    Args:\n        a: Numerator\n        b: Denominator\n\n    Returns:\n        Result of division\n\n    Raises:\n        ValueError: If b is zero\n    \"\"\"\n    if b == 0:\n        raise ValueError(\"Cannot divide by zero\")\n    return a / b\n</code></pre>"},{"location":"api/tools/#related-documentation","title":"Related Documentation","text":"<ul> <li>Architecture: Tool Registration - Registration flow</li> <li>Applications API - Creating tool providers</li> <li>Adapters API - Converting tool formats</li> </ul>"},{"location":"api/types/","title":"Types","text":""},{"location":"api/types/#types-api","title":"Types API","text":"<p>Type definitions, enums, and constants used throughout universal-mcp.</p>"},{"location":"api/types/#module-reference","title":"Module Reference","text":""},{"location":"api/types/#universal_mcp.types.ToolFormat","title":"ToolFormat","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported tool formats.</p>"},{"location":"api/types/#common-enums","title":"Common Enums","text":""},{"location":"api/types/#integrationtype","title":"IntegrationType","text":"<pre><code>from universal_mcp.types import IntegrationType\n\nIntegrationType.API_KEY    # \"api_key\"\nIntegrationType.OAUTH      # \"oauth\"\nIntegrationType.AGENTR     # \"agentr\"\n</code></pre>"},{"location":"api/types/#storetype","title":"StoreType","text":"<pre><code>from universal_mcp.types import StoreType\n\nStoreType.MEMORY       # \"memory\"\nStoreType.ENVIRONMENT  # \"environment\"\nStoreType.KEYRING      # \"keyring\"\n</code></pre>"},{"location":"api/types/#usage-examples","title":"Usage Examples","text":""},{"location":"api/types/#using-enums","title":"Using Enums","text":"<pre><code>from universal_mcp.types import IntegrationType, StoreType\n\n# Type-safe configuration\nintegration_type = IntegrationType.OAUTH\nstore_type = StoreType.KEYRING\n\n# String comparison\nif integration.type == IntegrationType.API_KEY:\n    # Handle API key integration\n    pass\n</code></pre>"},{"location":"api/types/#type-aliases","title":"Type Aliases","text":"<pre><code>from universal_mcp.types import ToolDict, CredentialsDict\n\n# Type hints\ndef process_tool(tool: ToolDict) -&gt; None:\n    \"\"\"Process a tool dictionary.\"\"\"\n    pass\n\ndef store_credentials(creds: CredentialsDict) -&gt; None:\n    \"\"\"Store credentials dictionary.\"\"\"\n    pass\n</code></pre>"},{"location":"api/types/#constants","title":"Constants","text":"<pre><code>from universal_mcp.types import (\n    DEFAULT_TIMEOUT,\n    DEFAULT_CALLBACK_PORT,\n    MCP_VERSION\n)\n\nprint(DEFAULT_TIMEOUT)        # 30 (seconds)\nprint(DEFAULT_CALLBACK_PORT)  # 8080\nprint(MCP_VERSION)            # \"1.0.0\"\n</code></pre>"},{"location":"api/types/#related-documentation","title":"Related Documentation","text":"<ul> <li>Configuration API - Using types in config</li> <li>Integrations API - Integration types</li> <li>Stores API - Store types</li> </ul>"},{"location":"architecture/","title":"Overview","text":""},{"location":"architecture/#architecture-documentation","title":"Architecture Documentation","text":"<p>Welcome to the universal-mcp architecture documentation. This section provides detailed technical diagrams and explanations of the internal architecture for contributors.</p>"},{"location":"architecture/#overview","title":"Overview","text":"<p>Universal-mcp is an MCP (Model Context Protocol) middleware framework that sits between AI agents and external applications/APIs. It provides credential management, tool registration, authentication flows, and flexible storage backends.</p>"},{"location":"architecture/#architecture-diagrams","title":"Architecture Diagrams","text":"<p>Navigate to the following sections to understand different aspects of the system:</p>"},{"location":"architecture/#core-architecture","title":"Core Architecture","text":"<ul> <li>System Architecture - High-level overview of how components interact</li> <li>Class Hierarchy - UML class diagrams showing inheritance relationships</li> </ul>"},{"location":"architecture/#runtime-flows","title":"Runtime Flows","text":"<ul> <li>Request Flow - Sequence diagram of how tool requests are processed</li> <li>Authentication Flow - OAuth, API Key, and AgentR authentication patterns</li> <li>Tool Registration - How tools are discovered and registered</li> <li>Server Initialization - Server startup sequences for LocalServer and SingleMCPServer</li> </ul>"},{"location":"architecture/#key-concepts","title":"Key Concepts","text":""},{"location":"architecture/#applications","title":"Applications","text":"<p>Applications are adapters that wrap external APIs or services. They expose tools that AI agents can call. Universal-mcp supports:</p> <ul> <li>APIApplication - RESTful HTTP API integrations</li> <li>GraphQLApplication - GraphQL API integrations</li> </ul>"},{"location":"architecture/#integrations","title":"Integrations","text":"<p>Integrations handle authentication and credential management:</p> <ul> <li>ApiKeyIntegration - Simple API key auth</li> <li>OAuthIntegration - OAuth 2.0 flows</li> <li>AgentRIntegration - Platform-managed credentials</li> </ul>"},{"location":"architecture/#stores","title":"Stores","text":"<p>Stores persist credentials and configuration:</p> <ul> <li>MemoryStore - In-memory (non-persistent)</li> <li>EnvironmentStore - OS environment variables</li> <li>KeyringStore - System keyring (secure)</li> </ul>"},{"location":"architecture/#servers","title":"Servers","text":"<p>Servers expose the MCP protocol to AI agents:</p> <ul> <li>LocalServer - Multi-application server with config file</li> <li>SingleMCPServer - Single application wrapper</li> </ul>"},{"location":"architecture/#for-contributors","title":"For Contributors","text":"<p>If you're contributing to universal-mcp:</p> <ol> <li>Start with the System Architecture to understand the big picture</li> <li>Review the Class Hierarchy to see how components relate</li> <li>Study relevant runtime flows to understand behavior</li> <li>Refer to the API Reference for detailed class documentation</li> </ol>"},{"location":"architecture/#diagrams-format","title":"Diagrams Format","text":"<p>All diagrams are created using Mermaid, a markdown-based diagramming tool. You can edit the diagram source directly in the markdown files.</p>"},{"location":"architecture/auth-flow/","title":"Authentication","text":""},{"location":"architecture/auth-flow/#authentication-flow","title":"Authentication Flow","text":"<p>This page details the three authentication patterns supported by universal-mcp: API Key, OAuth 2.0, and AgentR platform integration.</p>"},{"location":"architecture/auth-flow/#overview","title":"Overview","text":"<p>Universal-mcp supports multiple authentication strategies through the Integration abstraction:</p> <ol> <li>API Key Authentication - Simple token-based auth</li> <li>OAuth 2.0 Authentication - Full OAuth flow with token refresh</li> <li>AgentR Integration - Platform-managed credentials</li> </ol>"},{"location":"architecture/auth-flow/#api-key-authentication","title":"API Key Authentication","text":"<p>The simplest authentication method: store an API key and inject it into requests.</p>"},{"location":"architecture/auth-flow/#setup-flow","title":"Setup Flow","text":"<pre><code>sequenceDiagram\n    participant User\n    participant CLI as universal-mcp CLI\n    participant Int as ApiKeyIntegration\n    participant Store as Store\n\n    User-&gt;&gt;CLI: Set API key\n    CLI-&gt;&gt;Int: create ApiKeyIntegration(name, store)\n    User-&gt;&gt;Int: authorize()\n    Note over Int: Returns instructions:&lt;br/&gt;\"Please set GITHUB_API_KEY&lt;br/&gt;in your environment\"\n\n    User-&gt;&gt;Store: set(\"GITHUB_API_KEY\", \"ghp_...\")\n    Note over Store: Key stored securely\n</code></pre>"},{"location":"architecture/auth-flow/#request-flow","title":"Request Flow","text":"<pre><code>sequenceDiagram\n    participant App as Application\n    participant Int as ApiKeyIntegration\n    participant Store as Store\n    participant API as External API\n\n    App-&gt;&gt;Int: get_credentials()\n    Int-&gt;&gt;Store: get(\"GITHUB_API_KEY\")\n\n    alt Key exists\n        Store--&gt;&gt;Int: \"ghp_...\"\n        Int--&gt;&gt;App: {\"api_key\": \"ghp_...\"}\n\n        App-&gt;&gt;App: _get_headers()\n        Note over App: headers = {&lt;br/&gt;  \"Authorization\": \"Bearer ghp_...\"&lt;br/&gt;}\n\n        App-&gt;&gt;API: HTTP Request with auth header\n        API--&gt;&gt;App: 200 OK\n    else Key not found\n        Store--&gt;&gt;Int: KeyNotFoundError\n        Int--&gt;&gt;App: NotAuthorizedError\n        Note over App: Prompt user to authorize\n    end\n</code></pre>"},{"location":"architecture/auth-flow/#configuration-example","title":"Configuration Example","text":"<pre><code>applications:\n  - name: github\n    module: github_app\n    integration:\n      type: api_key\n      api_key_name: GITHUB_API_KEY\n      headers:\n        Authorization: \"Bearer {api_key}\"\n</code></pre>"},{"location":"architecture/auth-flow/#key-storage-options","title":"Key Storage Options","text":"Store Type Usage Security EnvironmentStore Environment variable Low - visible in process list KeyringStore System keyring High - encrypted by OS MemoryStore In-process only Medium - lost on restart"},{"location":"architecture/auth-flow/#oauth-20-authentication","title":"OAuth 2.0 Authentication","text":"<p>Full OAuth 2.0 authorization code flow with automatic token refresh.</p>"},{"location":"architecture/auth-flow/#initial-authorization-flow","title":"Initial Authorization Flow","text":"<pre><code>sequenceDiagram\n    participant User\n    participant App as Application\n    participant Int as OAuthIntegration\n    participant Local as CallbackServer\n    participant Browser\n    participant OAuth as OAuth Provider\n    participant Store as Store\n\n    User-&gt;&gt;App: Trigger authorization\n    App-&gt;&gt;Int: authorize()\n\n    Note over Int: Build auth URL with&lt;br/&gt;client_id, scopes, redirect_uri\n\n    Int-&gt;&gt;Local: Start callback server on localhost:8080\n    Int--&gt;&gt;User: Authorization URL\n    Int-&gt;&gt;Browser: Open URL in browser\n\n    Browser-&gt;&gt;OAuth: Authorization request\n    Note over OAuth: User logs in and&lt;br/&gt;grants permissions\n\n    OAuth-&gt;&gt;Local: Redirect with code\n    Local-&gt;&gt;Int: Receive authorization code\n\n    Int-&gt;&gt;OAuth: Exchange code for tokens&lt;br/&gt;POST /oauth/token\n    OAuth--&gt;&gt;Int: {&lt;br/&gt;  access_token: \"...\",&lt;br/&gt;  refresh_token: \"...\",&lt;br/&gt;  expires_in: 3600&lt;br/&gt;}\n\n    Int-&gt;&gt;Store: set(\"oauth_tokens\", {...})\n    Note over Store: Tokens stored securely\n\n    Int-&gt;&gt;Local: Stop callback server\n    Int--&gt;&gt;User: \"Authorization successful!\"\n</code></pre>"},{"location":"architecture/auth-flow/#token-usage-flow","title":"Token Usage Flow","text":"<pre><code>sequenceDiagram\n    participant App as Application\n    participant Int as OAuthIntegration\n    participant Store as Store\n    participant API as External API\n\n    App-&gt;&gt;Int: get_credentials()\n    Int-&gt;&gt;Store: get(\"oauth_tokens\")\n    Store--&gt;&gt;Int: {access_token, refresh_token, expires_at}\n\n    alt Token is valid (not expired)\n        Int--&gt;&gt;App: {access_token}\n        App-&gt;&gt;API: HTTP Request with Bearer token\n        API--&gt;&gt;App: 200 OK\n    else Token expired\n        Int-&gt;&gt;Int: refresh_token()\n        Note over Int: Use refresh_token to get new access_token\n        Int--&gt;&gt;App: {new_access_token}\n        App-&gt;&gt;API: HTTP Request with new token\n        API--&gt;&gt;App: 200 OK\n    end\n</code></pre>"},{"location":"architecture/auth-flow/#token-refresh-flow","title":"Token Refresh Flow","text":"<pre><code>sequenceDiagram\n    participant Int as OAuthIntegration\n    participant OAuth as OAuth Provider\n    participant Store as Store\n\n    Note over Int: Access token expired\n\n    Int-&gt;&gt;Store: get(\"oauth_tokens\")\n    Store--&gt;&gt;Int: {refresh_token}\n\n    Int-&gt;&gt;OAuth: POST /oauth/token&lt;br/&gt;{&lt;br/&gt;  grant_type: \"refresh_token\",&lt;br/&gt;  refresh_token: \"...\",&lt;br/&gt;  client_id: \"...\",&lt;br/&gt;  client_secret: \"...\"&lt;br/&gt;}\n\n    alt Refresh successful\n        OAuth--&gt;&gt;Int: {&lt;br/&gt;  access_token: \"new_token\",&lt;br/&gt;  refresh_token: \"new_refresh\",&lt;br/&gt;  expires_in: 3600&lt;br/&gt;}\n\n        Int-&gt;&gt;Store: set(\"oauth_tokens\", {...})\n        Note over Store: Updated tokens stored\n    else Refresh failed (token revoked)\n        OAuth--&gt;&gt;Int: 401 Unauthorized\n        Int-&gt;&gt;Store: delete(\"oauth_tokens\")\n        Note over Int: User must re-authorize\n    end\n</code></pre>"},{"location":"architecture/auth-flow/#configuration-example_1","title":"Configuration Example","text":"<pre><code>applications:\n  - name: slack\n    module: slack_app\n    integration:\n      type: oauth\n      client_id: ${SLACK_CLIENT_ID}\n      client_secret: ${SLACK_CLIENT_SECRET}\n      auth_url: https://slack.com/oauth/authorize\n      token_url: https://slack.com/api/oauth.access\n      scopes:\n        - chat:write\n        - channels:read\n      callback_port: 8080\n</code></pre>"},{"location":"architecture/auth-flow/#oauth-components","title":"OAuth Components","text":"<p>OAuthIntegration manages: - Authorization URL generation - Callback server (receives OAuth code) - Token exchange (code \u2192 access_token) - Token refresh (refresh_token \u2192 new access_token) - Token storage</p> <p>CallbackServer (internal): - Temporary HTTP server on localhost - Receives OAuth redirect - Extracts authorization code - Shuts down after successful callback</p>"},{"location":"architecture/auth-flow/#agentr-platform-integration","title":"AgentR Platform Integration","text":"<p>Delegates credential management to the AgentR platform.</p>"},{"location":"architecture/auth-flow/#authorization-flow","title":"Authorization Flow","text":"<pre><code>sequenceDiagram\n    participant User\n    participant App as Application\n    participant Int as AgentRIntegration\n    participant AgentR as AgentR Platform\n\n    User-&gt;&gt;App: Trigger authorization\n    App-&gt;&gt;Int: authorize()\n\n    Int-&gt;&gt;AgentR: Request auth details\n    AgentR--&gt;&gt;Int: {&lt;br/&gt;  message: \"Visit AgentR dashboard\",&lt;br/&gt;  auth_url: \"https://agentr.io/auth\",&lt;br/&gt;  integration_id: \"...\"&lt;br/&gt;}\n\n    Int--&gt;&gt;User: Display auth instructions\n\n    Note over User: User authorizes on&lt;br/&gt;AgentR platform\n\n    Note over AgentR: Credentials managed&lt;br/&gt;by platform\n</code></pre>"},{"location":"architecture/auth-flow/#credential-retrieval-flow","title":"Credential Retrieval Flow","text":"<pre><code>sequenceDiagram\n    participant App as Application\n    participant Int as AgentRIntegration\n    participant AgentR as AgentR Platform\n\n    App-&gt;&gt;Int: get_credentials()\n\n    Int-&gt;&gt;AgentR: GET /api/credentials/{integration_id}\n    Note over Int: Uses AgentR API key\n\n    alt Credentials available\n        AgentR--&gt;&gt;Int: {&lt;br/&gt;  access_token: \"...\",&lt;br/&gt;  credentials: {...}&lt;br/&gt;}\n        Int--&gt;&gt;App: credentials\n    else Not authorized\n        AgentR--&gt;&gt;Int: 403 Forbidden\n        Int--&gt;&gt;App: NotAuthorizedError\n    end\n</code></pre>"},{"location":"architecture/auth-flow/#configuration-example_2","title":"Configuration Example","text":"<pre><code>applications:\n  - name: gmail\n    module: gmail_app\n    integration:\n      type: agentr\n      integration_id: gmail_integration_123\n      agentr_api_key: ${AGENTR_API_KEY}\n</code></pre>"},{"location":"architecture/auth-flow/#benefits-of-agentr","title":"Benefits of AgentR","text":"<ol> <li>Centralized Management: All credentials in one platform</li> <li>Security: Credentials never stored locally</li> <li>Sharing: Team members share access without sharing credentials</li> <li>Audit: Platform tracks credential usage</li> <li>Rotation: Automatic credential rotation</li> </ol>"},{"location":"architecture/auth-flow/#comparison-matrix","title":"Comparison Matrix","text":"Feature API Key OAuth 2.0 AgentR Setup Complexity Low Medium Low Security Medium High High Token Refresh Manual Automatic Automatic User Experience Copy/paste key Browser flow Browser flow Revocation Manual Automatic Platform-managed Sharing Share key (insecure) Each user authorizes Platform sharing Best For Development, personal tools Production OAuth apps Enterprise, teams"},{"location":"architecture/auth-flow/#store-selection-guide","title":"Store Selection Guide","text":"<p>Different stores are appropriate for different scenarios:</p>"},{"location":"architecture/auth-flow/#memorystore","title":"MemoryStore","text":"<ul> <li>Use for: Testing, development</li> <li>Pros: Fast, no setup</li> <li>Cons: Lost on restart</li> <li>Security: Low (in-process memory)</li> </ul>"},{"location":"architecture/auth-flow/#environmentstore","title":"EnvironmentStore","text":"<ul> <li>Use for: CI/CD, containerized deployments</li> <li>Pros: Standard 12-factor approach</li> <li>Cons: Visible in process environment</li> <li>Security: Medium (process isolation)</li> </ul>"},{"location":"architecture/auth-flow/#keyringstore","title":"KeyringStore","text":"<ul> <li>Use for: Production, local development</li> <li>Pros: Secure, persistent, encrypted by OS</li> <li>Cons: Requires system keyring</li> <li>Security: High (OS-level encryption)</li> </ul>"},{"location":"architecture/auth-flow/#error-handling","title":"Error Handling","text":"<p>Common authentication errors and how they're handled:</p> <pre><code>graph TD\n    A[get_credentials] --&gt; B{Credentials exist?}\n    B --&gt;|No| C[NotAuthorizedError]\n    C --&gt; D[Prompt user to authorize]\n\n    B --&gt;|Yes| E{Token valid?}\n    E --&gt;|No| F{Has refresh token?}\n    F --&gt;|Yes| G[Refresh token]\n    G --&gt; H{Refresh success?}\n    H --&gt;|Yes| I[Return new token]\n    H --&gt;|No| C\n\n    F --&gt;|No| C\n    E --&gt;|Yes| I\n</code></pre>"},{"location":"architecture/auth-flow/#exception-hierarchy","title":"Exception Hierarchy","text":"<ul> <li><code>NotAuthorizedError</code>: No credentials found</li> <li><code>KeyNotFoundError</code>: Specific key missing from store</li> <li><code>TokenExpiredError</code>: Token expired and no refresh available</li> <li><code>OAuthError</code>: OAuth flow error (user denied, invalid client, etc.)</li> </ul>"},{"location":"architecture/auth-flow/#related-documentation","title":"Related Documentation","text":"<ul> <li>Request Flow - How auth fits into the request lifecycle</li> <li>Integrations API - Integration class reference</li> <li>Stores API - Store class reference</li> </ul>"},{"location":"architecture/class-hierarchy/","title":"Class Hierarchy","text":""},{"location":"architecture/class-hierarchy/#class-hierarchy","title":"Class Hierarchy","text":"<p>This page shows the inheritance relationships between core classes in universal-mcp using UML class diagrams.</p>"},{"location":"architecture/class-hierarchy/#overview","title":"Overview","text":"<p>Universal-mcp uses inheritance to provide extensibility points for: - Applications - Wrapping different API types - Integrations - Supporting different auth mechanisms - Stores - Using different credential storage backends - Servers - Deploying different server configurations</p>"},{"location":"architecture/class-hierarchy/#application-hierarchy","title":"Application Hierarchy","text":"<pre><code>classDiagram\n    class BaseApplication {\n        &lt;&lt;abstract&gt;&gt;\n        +str name\n        +__init__(name, **kwargs)\n        +list_tools()* list~Callable~\n    }\n\n    class APIApplication {\n        +Integration integration\n        +int default_timeout\n        +str base_url\n        +_get_headers() dict\n        +_make_request(method, endpoint, **kwargs) dict\n        +get(endpoint, **kwargs) dict\n        +post(endpoint, **kwargs) dict\n        +put(endpoint, **kwargs) dict\n        +delete(endpoint, **kwargs) dict\n        +patch(endpoint, **kwargs) dict\n    }\n\n    class GraphQLApplication {\n        +Integration integration\n        +str graphql_url\n        +_get_client() GraphQLClient\n        +execute_query(query, variables) dict\n        +execute_mutation(mutation, variables) dict\n    }\n\n    BaseApplication &lt;|-- APIApplication : extends\n    BaseApplication &lt;|-- GraphQLApplication : extends\n\n    class CustomAPIApp {\n        +list_tools() list~Callable~\n        +custom_tool_1()\n        +custom_tool_2()\n    }\n\n    APIApplication &lt;|-- CustomAPIApp : extends\n\n    note for BaseApplication \"Abstract base defines\\nthe interface all\\napplications must implement\"\n    note for APIApplication \"Provides HTTP client\\nand request helpers\"\n    note for GraphQLApplication \"Provides GraphQL\\nclient and query helpers\"\n</code></pre>"},{"location":"architecture/class-hierarchy/#key-points","title":"Key Points","text":"<ul> <li>BaseApplication: Abstract base class that all applications must inherit from</li> <li>Requires <code>list_tools()</code> method that returns callable functions</li> <li> <p>Each callable becomes a tool exposed to AI agents</p> </li> <li> <p>APIApplication: Base for REST API integrations</p> </li> <li>Manages httpx.Client for HTTP requests</li> <li>Provides convenience methods (get, post, put, delete, patch)</li> <li> <p>Handles authentication headers via Integration</p> </li> <li> <p>GraphQLApplication: Base for GraphQL integrations</p> </li> <li>Manages GQL client</li> <li>Provides query and mutation helpers</li> <li>Also uses Integration for auth</li> </ul>"},{"location":"architecture/class-hierarchy/#integration-hierarchy","title":"Integration Hierarchy","text":"<pre><code>classDiagram\n    class Integration {\n        +str name\n        +BaseStore store\n        +str type\n        +authorize() str|dict\n        +get_credentials() dict\n        +authorize_async() str|dict\n        +get_credentials_async() dict\n    }\n\n    class ApiKeyIntegration {\n        +str api_key_name\n        +dict headers\n        +authorize() str\n        +get_credentials() dict\n    }\n\n    class OAuthIntegration {\n        +str client_id\n        +str client_secret\n        +str auth_url\n        +str token_url\n        +list~str~ scopes\n        +authorize() str\n        +handle_callback(code) dict\n        +refresh_token() dict\n        +get_credentials() dict\n    }\n\n    class AgentRIntegration {\n        +authorize() dict\n        +get_credentials() dict\n    }\n\n    Integration &lt;|-- ApiKeyIntegration : extends\n    Integration &lt;|-- OAuthIntegration : extends\n    Integration &lt;|-- AgentRIntegration : extends\n\n    note for Integration \"Base class for\\nall auth strategies\"\n    note for ApiKeyIntegration \"Simple API key\\nin headers or params\"\n    note for OAuthIntegration \"Full OAuth 2.0 flow\\nwith token refresh\"\n    note for AgentRIntegration \"Delegates to\\nAgentR platform\"\n</code></pre>"},{"location":"architecture/class-hierarchy/#key-points_1","title":"Key Points","text":"<ul> <li>Integration: Base class for authentication strategies</li> <li>Stores credentials in a configurable Store</li> <li> <p>Provides both sync and async methods</p> </li> <li> <p>ApiKeyIntegration: Simplest auth method</p> </li> <li>Reads API key from store</li> <li> <p>Returns headers dict for requests</p> </li> <li> <p>OAuthIntegration: Full OAuth 2.0 implementation</p> </li> <li>Manages authorization flow</li> <li>Handles token exchange and refresh</li> <li> <p>Stores access/refresh tokens</p> </li> <li> <p>AgentRIntegration: Platform integration</p> </li> <li>Credentials managed by AgentR platform</li> <li>No local storage needed</li> </ul>"},{"location":"architecture/class-hierarchy/#store-hierarchy","title":"Store Hierarchy","text":"<pre><code>classDiagram\n    class BaseStore {\n        &lt;&lt;abstract&gt;&gt;\n        +get(key) Any*\n        +set(key, value)*\n        +delete(key)*\n        +list_keys() list~str~*\n        +clear()*\n    }\n\n    class MemoryStore {\n        -dict _storage\n        +get(key) Any\n        +set(key, value)\n        +delete(key)\n        +list_keys() list~str~\n        +clear()\n    }\n\n    class EnvironmentStore {\n        +get(key) Any\n        +set(key, value)\n        +delete(key)\n        +list_keys() list~str~\n        +clear()\n    }\n\n    class KeyringStore {\n        +str service_name\n        +get(key) Any\n        +set(key, value)\n        +delete(key)\n        +list_keys() list~str~\n        +clear()\n    }\n\n    BaseStore &lt;|-- MemoryStore : extends\n    BaseStore &lt;|-- EnvironmentStore : extends\n    BaseStore &lt;|-- KeyringStore : extends\n\n    note for BaseStore \"Abstract storage\\ninterface\"\n    note for MemoryStore \"In-memory dict\\n(non-persistent)\"\n    note for EnvironmentStore \"OS environment\\nvariables\"\n    note for KeyringStore \"System keyring\\n(secure, persistent)\"\n</code></pre>"},{"location":"architecture/class-hierarchy/#key-points_2","title":"Key Points","text":"<ul> <li>BaseStore: Abstract base for credential storage</li> <li>Simple key-value interface</li> <li> <p>All stores provide same API</p> </li> <li> <p>MemoryStore: In-memory only</p> </li> <li>Good for testing</li> <li> <p>Lost on process exit</p> </li> <li> <p>EnvironmentStore: Uses os.environ</p> </li> <li>Read from environment variables</li> <li> <p>Can write but not persistent across sessions</p> </li> <li> <p>KeyringStore: Production storage</p> </li> <li>Uses system keyring (macOS Keychain, Windows Credential Manager, etc.)</li> <li>Secure and persistent</li> </ul>"},{"location":"architecture/class-hierarchy/#server-hierarchy","title":"Server Hierarchy","text":"<pre><code>classDiagram\n    class BaseServer {\n        &lt;&lt;abstract&gt;&gt;\n        +list~BaseApplication~ applications\n        +ToolManager tool_manager\n        +BaseStore store\n        +__init__(applications, store)\n        +list_tools()* list~Tool~\n        +call_tool(name, arguments)* Any\n        +run()*\n    }\n\n    class LocalServer {\n        +ServerConfig config\n        +from_config(config_path) LocalServer\n        +list_tools() list~Tool~\n        +call_tool(name, arguments) Any\n        +run()\n    }\n\n    class SingleMCPServer {\n        +BaseApplication application\n        +__init__(application)\n        +list_tools() list~Tool~\n        +call_tool(name, arguments) Any\n        +run()\n    }\n\n    BaseServer &lt;|-- LocalServer : extends\n    BaseServer &lt;|-- SingleMCPServer : extends\n\n    note for BaseServer \"Uses FastMCP under\\nthe hood for MCP protocol\"\n    note for LocalServer \"Multi-app server\\nwith YAML config\"\n    note for SingleMCPServer \"Wraps single\\napplication\"\n</code></pre>"},{"location":"architecture/class-hierarchy/#key-points_3","title":"Key Points","text":"<ul> <li>BaseServer: Abstract base built on FastMCP</li> <li>Implements MCP protocol</li> <li>Manages tool registry</li> <li> <p>Routes tool calls</p> </li> <li> <p>LocalServer: Configuration-driven server</p> </li> <li>Loads apps from YAML config</li> <li>Supports multiple applications</li> <li> <p>Production deployment</p> </li> <li> <p>SingleMCPServer: Programmatic wrapper</p> </li> <li>Wraps one application</li> <li>Simpler for single-app scenarios</li> <li>Good for testing and development</li> </ul>"},{"location":"architecture/class-hierarchy/#tool-system-classes","title":"Tool System Classes","text":"<pre><code>classDiagram\n    class Tool {\n        +str name\n        +str description\n        +dict inputSchema\n        +Callable fn\n        +from_function(fn) Tool\n        +execute(**kwargs) Any\n    }\n\n    class ToolManager {\n        +dict~str,Tool~ _tools\n        +add_tool(tool)\n        +get_tool(name) Tool\n        +list_tools() list~Tool~\n        +call_tool(name, args) Any\n    }\n\n    class FuncMetadata {\n        +str name\n        +str description\n        +dict parameters\n        +extract_from_function(fn) FuncMetadata\n    }\n\n    ToolManager --&gt; Tool : manages\n    Tool --&gt; FuncMetadata : uses for schema\n</code></pre>"},{"location":"architecture/class-hierarchy/#key-points_4","title":"Key Points","text":"<ul> <li>Tool: Represents a callable tool</li> <li>Wraps a Python function</li> <li>Includes JSON schema for parameters</li> <li> <p>Handles execution</p> </li> <li> <p>ToolManager: Central tool registry</p> </li> <li>Stores all available tools</li> <li>Routes tool calls by name</li> <li> <p>Thread-safe</p> </li> <li> <p>FuncMetadata: Schema extraction</p> </li> <li>Parses function docstrings</li> <li>Generates JSON schemas from type hints</li> <li>Maps Python types to JSON Schema types</li> </ul>"},{"location":"architecture/class-hierarchy/#relationships-summary","title":"Relationships Summary","text":"<p>The class hierarchies provide clear extension points:</p> <ol> <li>Add new API type: Extend <code>APIApplication</code> or <code>GraphQLApplication</code></li> <li>Add auth method: Extend <code>Integration</code></li> <li>Add storage backend: Extend <code>BaseStore</code></li> <li>Add server type: Extend <code>BaseServer</code></li> </ol> <p>All extensions automatically work with the existing tool system and MCP protocol implementation.</p>"},{"location":"architecture/overview/","title":"System Architecture","text":""},{"location":"architecture/overview/#system-architecture","title":"System Architecture","text":"<p>This diagram shows the high-level architecture of universal-mcp and how components interact.</p>"},{"location":"architecture/overview/#overview","title":"Overview","text":"<p>Universal-mcp acts as middleware between AI agents (via MCP clients) and external applications/APIs. It handles authentication, credential storage, and tool registration/execution.</p>"},{"location":"architecture/overview/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>graph TB\n    subgraph \"AI Agent Layer\"\n        Agent[AI Agent&lt;br/&gt;Claude, GPT, etc.]\n    end\n\n    subgraph \"MCP Protocol Layer\"\n        MCPClient[MCP Client&lt;br/&gt;Claude Desktop, etc.]\n    end\n\n    subgraph \"Universal MCP Server\"\n        Server[BaseServer&lt;br/&gt;LocalServer / SingleMCPServer]\n        ToolMgr[ToolManager&lt;br/&gt;Tool Discovery &amp; Execution]\n\n        subgraph \"Integration Layer\"\n            Integration[Integration&lt;br/&gt;Auth Handler]\n            Store[Store&lt;br/&gt;Credential Storage]\n        end\n\n        subgraph \"Application Layer\"\n            App[BaseApplication&lt;br/&gt;API / GraphQL]\n            Tools[Tools&lt;br/&gt;Callable Functions]\n        end\n    end\n\n    subgraph \"External Services\"\n        API[External APIs&lt;br/&gt;REST, GraphQL, etc.]\n    end\n\n    Agent --&gt; MCPClient\n    MCPClient &lt;--&gt;|MCP Protocol| Server\n    Server --&gt; ToolMgr\n    ToolMgr --&gt; Tools\n    Tools --&gt; App\n    App --&gt; Integration\n    Integration --&gt; Store\n    App --&gt;|HTTP/GraphQL| API\n\n    style Agent fill:#e1f5ff\n    style MCPClient fill:#fff4e6\n    style Server fill:#f3e5f5\n    style ToolMgr fill:#f3e5f5\n    style Integration fill:#e8f5e9\n    style Store fill:#e8f5e9\n    style App fill:#fff3e0\n    style Tools fill:#fff3e0\n    style API fill:#fce4ec\n</code></pre>"},{"location":"architecture/overview/#component-descriptions","title":"Component Descriptions","text":""},{"location":"architecture/overview/#ai-agent-layer","title":"AI Agent Layer","text":"<ul> <li>AI Agent: The LLM (Large Language Model) that needs to call external tools</li> <li>Examples: Claude, GPT-4, Gemini</li> </ul>"},{"location":"architecture/overview/#mcp-protocol-layer","title":"MCP Protocol Layer","text":"<ul> <li>MCP Client: Implements the Model Context Protocol client</li> <li>Examples: Claude Desktop, VS Code extension</li> <li>Communicates with MCP servers using standard protocol</li> </ul>"},{"location":"architecture/overview/#universal-mcp-server","title":"Universal MCP Server","text":"<p>The core middleware layer with several key components:</p>"},{"location":"architecture/overview/#server-component","title":"Server Component","text":"<ul> <li>BaseServer: Abstract base for MCP servers</li> <li>LocalServer: Multi-application server with YAML config</li> <li>SingleMCPServer: Wraps a single application</li> </ul> <p>Responsibilities: - Handle MCP protocol requests (list_tools, call_tool) - Manage application lifecycle - Route tool calls to appropriate handlers</p>"},{"location":"architecture/overview/#tool-management","title":"Tool Management","text":"<ul> <li>ToolManager: Central registry for tools</li> <li>Tools: Individual callable functions with schemas</li> </ul> <p>Responsibilities: - Discover tools from applications - Parse docstrings to generate schemas - Route tool calls to correct application</p>"},{"location":"architecture/overview/#integration-layer","title":"Integration Layer","text":"<ul> <li>Integration: Handles authentication strategies</li> <li>ApiKeyIntegration: Simple API key auth</li> <li>OAuthIntegration: OAuth 2.0 flow</li> <li> <p>AgentRIntegration: Platform-managed credentials</p> </li> <li> <p>Store: Persists credentials securely</p> </li> <li>MemoryStore: Non-persistent (testing)</li> <li>EnvironmentStore: OS environment variables</li> <li>KeyringStore: System keyring (production)</li> </ul> <p>Responsibilities: - Manage authentication flows - Store and retrieve credentials - Inject auth into application requests</p>"},{"location":"architecture/overview/#application-layer","title":"Application Layer","text":"<ul> <li>BaseApplication: Abstract application interface</li> <li>APIApplication: REST API wrapper</li> <li>GraphQLApplication: GraphQL API wrapper</li> </ul> <p>Responsibilities: - Define available tools as Python functions - Make authenticated requests to external APIs - Parse responses and handle errors</p>"},{"location":"architecture/overview/#external-services","title":"External Services","text":"<ul> <li>External APIs: The actual services being integrated</li> <li>Examples: GitHub, Slack, Google Calendar, etc.</li> </ul>"},{"location":"architecture/overview/#request-flow-summary","title":"Request Flow Summary","text":"<ol> <li>AI Agent needs to call a tool (e.g., \"create_github_issue\")</li> <li>MCP Client sends tool call request to Universal MCP Server</li> <li>Server routes to ToolManager</li> <li>ToolManager finds the tool and invokes it</li> <li>Tool calls the Application method</li> <li>Application gets credentials from Integration/Store</li> <li>Application makes authenticated HTTP/GraphQL request to External API</li> <li>Response flows back through the stack</li> <li>Result returned to AI Agent via MCP Client</li> </ol> <p>For detailed sequence diagrams, see: - Request Flow - Detailed tool execution flow - Authentication Flow - Credential retrieval patterns</p>"},{"location":"architecture/overview/#configuration","title":"Configuration","text":"<p>Universal-mcp can be configured via:</p> <ol> <li> <p>YAML Config Files (LocalServer)    - Define multiple applications    - Configure integrations and stores    - Set server options</p> </li> <li> <p>Environment Variables    - API keys and credentials    - Server settings</p> </li> <li> <p>Programmatic Config (SingleMCPServer)    - Import applications as Python modules    - Dynamic configuration</p> </li> </ol> <p>See Configuration API for details.</p>"},{"location":"architecture/request-flow/","title":"Request Flow","text":""},{"location":"architecture/request-flow/#request-flow","title":"Request Flow","text":"<p>This page shows the detailed sequence of events when an AI agent calls a tool through universal-mcp.</p>"},{"location":"architecture/request-flow/#overview","title":"Overview","text":"<p>When an AI agent wants to call a tool (e.g., \"create a GitHub issue\"), the request flows through multiple layers: 1. MCP Client \u2192 MCP Server 2. Server \u2192 Tool Manager 3. Tool Manager \u2192 Tool 4. Tool \u2192 Application 5. Application \u2192 Integration \u2192 Store (for credentials) 6. Application \u2192 External API 7. Response flows back up the chain</p>"},{"location":"architecture/request-flow/#complete-request-flow","title":"Complete Request Flow","text":"<pre><code>sequenceDiagram\n    participant Agent as AI Agent\n    participant Client as MCP Client\n    participant Server as BaseServer\n    participant ToolMgr as ToolManager\n    participant Tool as Tool\n    participant App as Application\n    participant Int as Integration\n    participant Store as Store\n    participant API as External API\n\n    Agent-&gt;&gt;Client: \"Create GitHub issue\"\n    Client-&gt;&gt;Server: call_tool(\"create_issue\", args)\n\n    Note over Server: Server validates request\n\n    Server-&gt;&gt;ToolMgr: call_tool(\"create_issue\", args)\n    ToolMgr-&gt;&gt;ToolMgr: Find tool by name\n\n    ToolMgr-&gt;&gt;Tool: execute(**args)\n    Note over Tool: Validate args against schema\n\n    Tool-&gt;&gt;App: create_issue(title, body, ...)\n\n    Note over App: Need credentials for API\n    App-&gt;&gt;Int: get_credentials()\n    Int-&gt;&gt;Store: get(\"github_token\")\n    Store--&gt;&gt;Int: {\"access_token\": \"ghp_...\"}\n    Int--&gt;&gt;App: {\"access_token\": \"ghp_...\"}\n\n    Note over App: Build authenticated request\n    App-&gt;&gt;App: _get_headers()\n    App-&gt;&gt;API: POST /repos/.../issues&lt;br/&gt;{auth headers, body}\n\n    API--&gt;&gt;App: 201 Created&lt;br/&gt;{issue data}\n\n    Note over App: Parse response\n    App--&gt;&gt;Tool: {issue_number, url, ...}\n    Tool--&gt;&gt;ToolMgr: {issue_number, url, ...}\n    ToolMgr--&gt;&gt;Server: {issue_number, url, ...}\n    Server--&gt;&gt;Client: MCP Response&lt;br/&gt;{content: [...]}\n    Client--&gt;&gt;Agent: \"Created issue #123\"\n</code></pre>"},{"location":"architecture/request-flow/#step-by-step-breakdown","title":"Step-by-Step Breakdown","text":""},{"location":"architecture/request-flow/#1-tool-discovery-initialization","title":"1. Tool Discovery (Initialization)","text":"<p>Before any tool can be called, it must be registered. This happens during server startup:</p> <pre><code>sequenceDiagram\n    participant Server as BaseServer\n    participant App as Application\n    participant ToolMgr as ToolManager\n    participant Tool as Tool\n\n    Server-&gt;&gt;App: list_tools()\n    App--&gt;&gt;Server: [fn1, fn2, fn3]\n\n    loop For each function\n        Server-&gt;&gt;Tool: from_function(fn)\n        Note over Tool: Parse docstring&lt;br/&gt;Extract schema&lt;br/&gt;Create Tool instance\n        Tool--&gt;&gt;Server: Tool instance\n        Server-&gt;&gt;ToolMgr: add_tool(tool)\n    end\n\n    Note over ToolMgr: All tools registered&lt;br/&gt;Ready to serve requests\n</code></pre>"},{"location":"architecture/request-flow/#2-tool-invocation","title":"2. Tool Invocation","text":"<p>When the agent wants to call a tool:</p> <pre><code>sequenceDiagram\n    participant Client as MCP Client\n    participant Server as BaseServer\n    participant ToolMgr as ToolManager\n\n    Client-&gt;&gt;Server: call_tool(name=\"create_issue\", arguments={...})\n    Server-&gt;&gt;ToolMgr: call_tool(\"create_issue\", {...})\n\n    alt Tool exists\n        ToolMgr--&gt;&gt;Server: result\n        Server--&gt;&gt;Client: success response\n    else Tool not found\n        ToolMgr--&gt;&gt;Server: ToolNotFoundError\n        Server--&gt;&gt;Client: error response\n    end\n</code></pre>"},{"location":"architecture/request-flow/#3-argument-validation","title":"3. Argument Validation","text":"<p>The Tool validates arguments against its JSON schema:</p> <pre><code>sequenceDiagram\n    participant ToolMgr as ToolManager\n    participant Tool as Tool\n    participant Fn as Function\n\n    ToolMgr-&gt;&gt;Tool: execute(**arguments)\n\n    Note over Tool: Validate args against&lt;br/&gt;inputSchema\n\n    alt Valid arguments\n        Tool-&gt;&gt;Fn: fn(**arguments)\n        Fn--&gt;&gt;Tool: result\n        Tool--&gt;&gt;ToolMgr: result\n    else Invalid arguments\n        Tool--&gt;&gt;ToolMgr: ValidationError\n    end\n</code></pre>"},{"location":"architecture/request-flow/#4-authentication","title":"4. Authentication","text":"<p>The application retrieves credentials:</p> <pre><code>sequenceDiagram\n    participant App as Application\n    participant Int as Integration\n    participant Store as Store\n\n    App-&gt;&gt;Int: get_credentials()\n\n    alt Credentials exist\n        Int-&gt;&gt;Store: get(key)\n        Store--&gt;&gt;Int: credential_data\n        Int--&gt;&gt;App: credentials\n    else Not authorized\n        Int--&gt;&gt;App: NotAuthorizedError\n    end\n\n    App-&gt;&gt;App: _get_headers()\n    Note over App: Inject credentials into&lt;br/&gt;request headers\n</code></pre>"},{"location":"architecture/request-flow/#5-api-request","title":"5. API Request","text":"<p>The application makes the external API call:</p> <pre><code>sequenceDiagram\n    participant App as APIApplication\n    participant HTTP as httpx.Client\n    participant API as External API\n\n    App-&gt;&gt;HTTP: request(method, url, headers, json)\n    HTTP-&gt;&gt;API: HTTP Request\n\n    alt Success (2xx)\n        API--&gt;&gt;HTTP: 200/201 Response\n        HTTP--&gt;&gt;App: response.json()\n    else Client Error (4xx)\n        API--&gt;&gt;HTTP: 400/401/404 Response\n        HTTP--&gt;&gt;App: HTTPError\n    else Server Error (5xx)\n        API--&gt;&gt;HTTP: 500 Response\n        HTTP--&gt;&gt;App: HTTPError\n    end\n</code></pre>"},{"location":"architecture/request-flow/#6-response-processing","title":"6. Response Processing","text":"<p>The response flows back up the stack:</p> <pre><code>sequenceDiagram\n    participant App as Application\n    participant Tool as Tool\n    participant ToolMgr as ToolManager\n    participant Server as BaseServer\n    participant Client as MCP Client\n\n    App--&gt;&gt;Tool: result data\n    Note over Tool: May format/validate&lt;br/&gt;response\n\n    Tool--&gt;&gt;ToolMgr: result\n    ToolMgr--&gt;&gt;Server: result\n\n    Note over Server: Wrap in MCP format\n    Server--&gt;&gt;Client: {&lt;br/&gt;  content: [{&lt;br/&gt;    type: \"text\",&lt;br/&gt;    text: result&lt;br/&gt;  }]&lt;br/&gt;}\n</code></pre>"},{"location":"architecture/request-flow/#error-handling","title":"Error Handling","text":"<p>Errors at any layer are propagated back to the client:</p> <pre><code>sequenceDiagram\n    participant Client as MCP Client\n    participant Server as BaseServer\n    participant ToolMgr as ToolManager\n    participant Tool as Tool\n    participant App as Application\n    participant API as External API\n\n    Client-&gt;&gt;Server: call_tool(...)\n    Server-&gt;&gt;ToolMgr: call_tool(...)\n    ToolMgr-&gt;&gt;Tool: execute(...)\n    Tool-&gt;&gt;App: tool_function(...)\n    App-&gt;&gt;API: HTTP Request\n\n    alt API Error\n        API--&gt;&gt;App: 401 Unauthorized\n        App--&gt;&gt;Tool: NotAuthorizedError\n        Tool--&gt;&gt;ToolMgr: NotAuthorizedError\n        ToolMgr--&gt;&gt;Server: NotAuthorizedError\n        Server--&gt;&gt;Client: Error Response:&lt;br/&gt;\"Not authorized. Please run&lt;br/&gt;authorize() first.\"\n    end\n</code></pre>"},{"location":"architecture/request-flow/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/request-flow/#caching","title":"Caching","text":"<ul> <li>Tool schemas: Cached after first generation</li> <li>HTTP connections: Reused via httpx.Client</li> <li>Credentials: Cached in memory after first retrieval</li> </ul>"},{"location":"architecture/request-flow/#async-support","title":"Async Support","text":"<p>Universal-mcp supports async/await for: - <code>get_credentials_async()</code> - <code>authorize_async()</code> - Async application methods</p> <p>This allows non-blocking I/O for better performance.</p>"},{"location":"architecture/request-flow/#connection-pooling","title":"Connection Pooling","text":"<p>APIApplication uses httpx.Client which: - Maintains connection pool - Reuses TCP connections - Supports HTTP/2</p>"},{"location":"architecture/request-flow/#related-documentation","title":"Related Documentation","text":"<ul> <li>Authentication Flow - Details on credential retrieval</li> <li>Tool Registration - How tools are discovered</li> <li>Server Initialization - Server startup sequence</li> </ul>"},{"location":"architecture/server-init/","title":"Server Initialization","text":""},{"location":"architecture/server-init/#server-initialization","title":"Server Initialization","text":"<p>This page documents the startup sequences for LocalServer and SingleMCPServer, showing how configuration is loaded and applications are initialized.</p>"},{"location":"architecture/server-init/#overview","title":"Overview","text":"<p>Universal-mcp provides two server types:</p> <ol> <li>LocalServer - Multi-application server configured via YAML</li> <li>SingleMCPServer - Programmatic wrapper for a single application</li> </ol> <p>Each has different initialization flows optimized for their use case.</p>"},{"location":"architecture/server-init/#localserver-initialization","title":"LocalServer Initialization","text":"<p>LocalServer loads multiple applications from a YAML configuration file.</p>"},{"location":"architecture/server-init/#complete-startup-flow","title":"Complete Startup Flow","text":"<pre><code>sequenceDiagram\n    participant CLI as CLI/User\n    participant Server as LocalServer\n    participant Config as ServerConfig\n    participant Store as Store Factory\n    participant Int as Integration Factory\n    participant App as Application Loader\n    participant ToolMgr as ToolManager\n\n    CLI-&gt;&gt;Server: from_config(\"config.yaml\")\n\n    Server-&gt;&gt;Config: Load YAML file\n    Config-&gt;&gt;Config: Parse and validate\n    Config--&gt;&gt;Server: ServerConfig object\n\n    Note over Server: Create server instance\n\n    Server-&gt;&gt;Store: Create store from config\n    alt KeyringStore\n        Store-&gt;&gt;Store: Connect to system keyring\n    else EnvironmentStore\n        Store-&gt;&gt;Store: Access os.environ\n    else MemoryStore\n        Store-&gt;&gt;Store: Create in-memory dict\n    end\n    Store--&gt;&gt;Server: Store instance\n\n    loop For each application in config\n        Server-&gt;&gt;Int: Create integration\n        Int-&gt;&gt;Store: Link to store\n        Int--&gt;&gt;Server: Integration instance\n\n        Server-&gt;&gt;App: Load application module\n        App-&gt;&gt;App: Import Python module\n        App-&gt;&gt;App: Instantiate app class\n        App--&gt;&gt;Server: Application instance\n\n        Server-&gt;&gt;App: list_tools()\n        App--&gt;&gt;Server: [tool1, tool2, ...]\n\n        loop For each tool\n            Server-&gt;&gt;ToolMgr: Register tool\n        end\n    end\n\n    Note over Server: Server ready\n\n    Server-&gt;&gt;Server: run()\n    Note over Server: Start FastMCP server&lt;br/&gt;Listen for MCP requests\n</code></pre>"},{"location":"architecture/server-init/#configuration-loading","title":"Configuration Loading","text":"<pre><code>flowchart TD\n    A[config.yaml] --&gt; B[Read file]\n    B --&gt; C[Parse YAML]\n    C --&gt; D{Valid?}\n\n    D --&gt;|No| E[ConfigurationError]\n    D --&gt;|Yes| F[Create Pydantic models]\n\n    F --&gt; G[ServerConfig]\n    G --&gt; H[StoreConfig]\n    G --&gt; I[AppConfig list]\n\n    I --&gt; J[For each app]\n    J --&gt; K[Resolve environment variables]\n    J --&gt; L[Validate required fields]\n    J --&gt; M[Create IntegrationConfig]\n</code></pre>"},{"location":"architecture/server-init/#example-configuration","title":"Example Configuration","text":"<pre><code># config.yaml\nstore:\n  type: keyring\n  service_name: universal-mcp\n\napplications:\n  - name: github\n    module: universal_mcp.applications.github\n    class_name: GitHubApp\n    integration:\n      type: oauth\n      client_id: ${GITHUB_CLIENT_ID}\n      client_secret: ${GITHUB_CLIENT_SECRET}\n      auth_url: https://github.com/login/oauth/authorize\n      token_url: https://github.com/login/oauth/access_token\n      scopes:\n        - repo\n        - user\n\n  - name: slack\n    module: my_apps.slack_app\n    class_name: SlackApp\n    integration:\n      type: api_key\n      api_key_name: SLACK_BOT_TOKEN\n      headers:\n        Authorization: \"Bearer {api_key}\"\n</code></pre>"},{"location":"architecture/server-init/#store-creation","title":"Store Creation","text":"<pre><code>flowchart TD\n    A[StoreConfig] --&gt; B{Store type?}\n\n    B --&gt;|keyring| C[Create KeyringStore]\n    C --&gt; D[service_name from config]\n    D --&gt; E[KeyringStore instance]\n\n    B --&gt;|environment| F[Create EnvironmentStore]\n    F --&gt; E\n\n    B --&gt;|memory| G[Create MemoryStore]\n    G --&gt; E\n\n    B --&gt;|custom| H[Import custom class]\n    H --&gt; I[Instantiate custom store]\n    I --&gt; E\n</code></pre>"},{"location":"architecture/server-init/#application-loading","title":"Application Loading","text":"<pre><code>sequenceDiagram\n    participant Server as LocalServer\n    participant Loader as ApplicationLoader\n    participant Module as Python Module System\n    participant AppClass as Application Class\n\n    Server-&gt;&gt;Loader: Load application from config\n    Loader-&gt;&gt;Module: importlib.import_module(app.module)\n    Module--&gt;&gt;Loader: Module object\n\n    Loader-&gt;&gt;Module: getattr(module, app.class_name)\n    Module--&gt;&gt;Loader: Application class\n\n    Loader-&gt;&gt;AppClass: __init__(name, integration, **kwargs)\n    AppClass--&gt;&gt;Loader: Application instance\n\n    Loader--&gt;&gt;Server: Application ready\n</code></pre>"},{"location":"architecture/server-init/#error-handling-during-startup","title":"Error Handling During Startup","text":"<pre><code>flowchart TD\n    A[Start initialization] --&gt; B{Config file exists?}\n    B --&gt;|No| C[ConfigurationError]\n    B --&gt;|Yes| D{Valid YAML?}\n\n    D --&gt;|No| E[YAMLError]\n    D --&gt;|Yes| F{Schema valid?}\n\n    F --&gt;|No| G[ValidationError]\n    F --&gt;|Yes| H{Module importable?}\n\n    H --&gt;|No| I[ImportError]\n    H --&gt;|Yes| J{Class exists?}\n\n    J --&gt;|No| K[AttributeError]\n    J --&gt;|Yes| L{App init successful?}\n\n    L --&gt;|No| M[InitializationError]\n    L --&gt;|Yes| N[Application loaded]\n\n    C --&gt; O[Exit with error]\n    E --&gt; O\n    G --&gt; O\n    I --&gt; O\n    K --&gt; O\n    M --&gt; O\n\n    N --&gt; P[Continue with next app]\n</code></pre>"},{"location":"architecture/server-init/#singlemcpserver-initialization","title":"SingleMCPServer Initialization","text":"<p>SingleMCPServer wraps a single application instance with minimal configuration.</p>"},{"location":"architecture/server-init/#startup-flow","title":"Startup Flow","text":"<pre><code>sequenceDiagram\n    participant User as Developer\n    participant App as Application Instance\n    participant Server as SingleMCPServer\n    participant ToolMgr as ToolManager\n\n    Note over User: Create application programmatically\n\n    User-&gt;&gt;App: Create application instance&lt;br/&gt;my_app = MyApp(...)\n\n    User-&gt;&gt;Server: SingleMCPServer(my_app)\n\n    Server-&gt;&gt;Server: Initialize FastMCP\n    Server-&gt;&gt;Server: Set up tool registry\n\n    Note over Server: Lazy loading -&lt;br/&gt;tools not loaded yet\n\n    User-&gt;&gt;Server: run()\n\n    Note over Server: First request triggers&lt;br/&gt;tool discovery\n\n    Server-&gt;&gt;App: list_tools()\n    App--&gt;&gt;Server: [tool1, tool2, ...]\n\n    loop For each tool\n        Server-&gt;&gt;ToolMgr: Register tool\n    end\n\n    Note over Server: Server ready,&lt;br/&gt;handle requests\n</code></pre>"},{"location":"architecture/server-init/#lazy-tool-loading","title":"Lazy Tool Loading","text":"<p>SingleMCPServer uses lazy loading for better performance:</p> <pre><code>flowchart TD\n    A[SingleMCPServer created] --&gt; B[Server running]\n    B --&gt; C{First request received?}\n\n    C --&gt;|No| D[Wait for request]\n    D --&gt; C\n\n    C --&gt;|Yes| E{Tools loaded?}\n    E --&gt;|No| F[Load tools from app]\n    F --&gt; G[Cache tools]\n    G --&gt; H[Handle request]\n\n    E --&gt;|Yes| H\n    H --&gt; I[Subsequent requests]\n    I --&gt; H\n</code></pre>"},{"location":"architecture/server-init/#example-usage","title":"Example Usage","text":"<pre><code>from universal_mcp.applications import APIApplication\nfrom universal_mcp.servers import SingleMCPServer\nfrom universal_mcp.integrations import ApiKeyIntegration\nfrom universal_mcp.stores import KeyringStore\n\n# Create store\nstore = KeyringStore(service_name=\"my-app\")\n\n# Create integration\nintegration = ApiKeyIntegration(\n    name=\"my_api_key\",\n    store=store,\n    api_key_name=\"MY_API_KEY\"\n)\n\n# Create application\nclass MyApp(APIApplication):\n    def __init__(self):\n        super().__init__(\n            name=\"my_app\",\n            integration=integration\n        )\n        self.base_url = \"https://api.example.com\"\n\n    def list_tools(self):\n        return [self.get_data]\n\n    def get_data(self, query: str) -&gt; dict:\n        \"\"\"Get data from API.\"\"\"\n        return self.get(f\"/data?q={query}\")\n\n# Create and run server\napp = MyApp()\nserver = SingleMCPServer(app)\nserver.run()  # Blocks and serves MCP requests\n</code></pre>"},{"location":"architecture/server-init/#comparison-localserver-vs-singlemcpserver","title":"Comparison: LocalServer vs SingleMCPServer","text":"Feature LocalServer SingleMCPServer Configuration YAML file Programmatic Applications Multiple Single Tool Loading Eager (at startup) Lazy (on first request) Best For Production, multiple integrations Development, testing Store Setup Configured in YAML Passed to application Reload Requires restart Requires restart Complexity Higher Lower"},{"location":"architecture/server-init/#server-lifecycle","title":"Server Lifecycle","text":""},{"location":"architecture/server-init/#localserver-lifecycle","title":"LocalServer Lifecycle","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Created: from_config()\n    Created --&gt; Configuring: Load YAML\n    Configuring --&gt; CreatingStore: Parse config\n    CreatingStore --&gt; LoadingApps: Initialize store\n    LoadingApps --&gt; RegisteringTools: For each app\n    RegisteringTools --&gt; Ready: All tools registered\n    Ready --&gt; Running: run()\n    Running --&gt; Serving: Handle MCP requests\n    Serving --&gt; Serving: Process tool calls\n    Serving --&gt; Shutdown: SIGTERM/SIGINT\n    Shutdown --&gt; [*]\n</code></pre>"},{"location":"architecture/server-init/#singlemcpserver-lifecycle","title":"SingleMCPServer Lifecycle","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Created: __init__(app)\n    Created --&gt; Ready: Minimal setup\n    Ready --&gt; Running: run()\n    Running --&gt; LazyLoad: First request\n    LazyLoad --&gt; Serving: Tools loaded\n    Serving --&gt; Serving: Process tool calls\n    Serving --&gt; Shutdown: SIGTERM/SIGINT\n    Shutdown --&gt; [*]\n</code></pre>"},{"location":"architecture/server-init/#configuration-validation","title":"Configuration Validation","text":"<p>LocalServer validates configuration at startup:</p> <pre><code>flowchart TD\n    A[ServerConfig] --&gt; B{All required fields present?}\n    B --&gt;|No| C[Missing field error]\n\n    B --&gt;|Yes| D{Store type valid?}\n    D --&gt;|No| E[Invalid store type]\n\n    D --&gt;|Yes| F[Validate each AppConfig]\n    F --&gt; G{Module path valid?}\n    G --&gt;|No| H[Invalid module path]\n\n    G --&gt;|Yes| I{Integration config valid?}\n    I --&gt;|No| J[Invalid integration]\n\n    I --&gt;|Yes| K{Required env vars set?}\n    K --&gt;|No| L[Missing environment variable]\n\n    K --&gt;|Yes| M[Configuration valid]\n\n    C --&gt; N[Startup failed]\n    E --&gt; N\n    H --&gt; N\n    J --&gt; N\n    L --&gt; N\n\n    M --&gt; O[Proceed with initialization]\n</code></pre>"},{"location":"architecture/server-init/#common-validation-errors","title":"Common Validation Errors","text":"Error Cause Solution <code>ConfigurationError</code> Invalid YAML syntax Fix YAML formatting <code>ModuleNotFoundError</code> Application module not found Check module path, install package <code>AttributeError</code> Class name not found in module Check class_name in config <code>ValidationError</code> Missing required field Add required fields to config <code>EnvironmentError</code> Environment variable not set Set required environment variables"},{"location":"architecture/server-init/#hot-reload-future-feature","title":"Hot Reload (Future Feature)","text":"<p>Currently, both servers require restart for configuration changes. Future versions may support hot reload:</p> <pre><code>sequenceDiagram\n    participant FS as File System\n    participant Watcher as Config Watcher\n    participant Server as Server\n\n    FS-&gt;&gt;Watcher: config.yaml modified\n    Watcher-&gt;&gt;Server: Configuration changed event\n\n    Server-&gt;&gt;Server: Pause request handling\n    Server-&gt;&gt;Server: Reload configuration\n    Server-&gt;&gt;Server: Reinitialize applications\n    Server-&gt;&gt;Server: Update tool registry\n    Server-&gt;&gt;Server: Resume request handling\n\n    Note over Server: Zero-downtime reload\n</code></pre>"},{"location":"architecture/server-init/#debugging-startup-issues","title":"Debugging Startup Issues","text":""},{"location":"architecture/server-init/#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n\n# Then run server\nserver = LocalServer.from_config(\"config.yaml\")\n</code></pre>"},{"location":"architecture/server-init/#check-configuration","title":"Check Configuration","text":"<pre><code>from universal_mcp.config import ServerConfig\n\n# Load and validate without starting server\nconfig = ServerConfig.from_yaml(\"config.yaml\")\nprint(config.model_dump_json(indent=2))\n</code></pre>"},{"location":"architecture/server-init/#test-application-loading","title":"Test Application Loading","text":"<pre><code>from universal_mcp.applications.utils import load_application\n\n# Test loading a single app\napp = load_application({\n    \"name\": \"test\",\n    \"module\": \"my_module\",\n    \"class_name\": \"MyApp\"\n})\nprint(f\"Loaded: {app}\")\nprint(f\"Tools: {app.list_tools()}\")\n</code></pre>"},{"location":"architecture/server-init/#related-documentation","title":"Related Documentation","text":"<ul> <li>System Architecture - High-level architecture</li> <li>Tool Registration - What happens after initialization</li> <li>Configuration API - Configuration schema reference</li> <li>Servers API - Server class reference</li> </ul>"},{"location":"architecture/tool-registration/","title":"Tool Registration","text":""},{"location":"architecture/tool-registration/#tool-registration","title":"Tool Registration","text":"<p>This page explains how universal-mcp discovers tools from applications, parses their schemas, and registers them for use by AI agents.</p>"},{"location":"architecture/tool-registration/#overview","title":"Overview","text":"<p>Tool registration is the process of: 1. Discovering callable functions from applications 2. Parsing docstrings and type hints 3. Generating JSON schemas 4. Registering tools in the ToolManager</p> <p>This happens during server initialization, before any tool calls are made.</p>"},{"location":"architecture/tool-registration/#complete-registration-flow","title":"Complete Registration Flow","text":"<pre><code>sequenceDiagram\n    participant Server as BaseServer\n    participant App as Application\n    participant Tool as Tool\n    participant Parser as DocstringParser\n    participant ToolMgr as ToolManager\n\n    Note over Server: Server starting up\n\n    Server-&gt;&gt;App: list_tools()\n    App--&gt;&gt;Server: [create_issue, list_issues, ...]\n\n    loop For each function\n        Server-&gt;&gt;Tool: from_function(fn)\n\n        Tool-&gt;&gt;Parser: parse_docstring(fn.__doc__)\n        Parser--&gt;&gt;Tool: {description, params}\n\n        Tool-&gt;&gt;Tool: extract_type_hints(fn)\n        Tool-&gt;&gt;Tool: generate_json_schema(params, hints)\n\n        Note over Tool: Tool instance created with:&lt;br/&gt;- name&lt;br/&gt;- description&lt;br/&gt;- inputSchema&lt;br/&gt;- callable\n\n        Tool--&gt;&gt;Server: Tool instance\n\n        Server-&gt;&gt;ToolMgr: add_tool(tool)\n        Note over ToolMgr: Tool registered and&lt;br/&gt;available for calls\n    end\n\n    Note over Server: All tools registered,&lt;br/&gt;server ready\n</code></pre>"},{"location":"architecture/tool-registration/#step-1-application-discovery","title":"Step 1: Application Discovery","text":"<p>During server initialization, each application is asked to list its tools:</p> <pre><code>sequenceDiagram\n    participant Server as BaseServer\n    participant App1 as GitHubApp\n    participant App2 as SlackApp\n\n    Server-&gt;&gt;App1: list_tools()\n    App1--&gt;&gt;Server: [&lt;br/&gt;  create_issue,&lt;br/&gt;  list_issues,&lt;br/&gt;  create_pr&lt;br/&gt;]\n\n    Server-&gt;&gt;App2: list_tools()\n    App2--&gt;&gt;Server: [&lt;br/&gt;  send_message,&lt;br/&gt;  list_channels&lt;br/&gt;]\n\n    Note over Server: 5 tools discovered\n</code></pre>"},{"location":"architecture/tool-registration/#application-implementation","title":"Application Implementation","text":"<p>Applications define tools as methods:</p> <pre><code>class GitHubApp(APIApplication):\n    def list_tools(self) -&gt; list[Callable]:\n        return [\n            self.create_issue,\n            self.list_issues,\n            self.create_pull_request,\n        ]\n\n    def create_issue(\n        self,\n        title: str,\n        body: str,\n        labels: list[str] | None = None\n    ) -&gt; dict:\n        \"\"\"Create a new GitHub issue.\n\n        Args:\n            title: The issue title\n            body: The issue description\n            labels: Optional list of label names\n\n        Returns:\n            The created issue data including number and URL\n        \"\"\"\n        # Implementation\n</code></pre>"},{"location":"architecture/tool-registration/#step-2-docstring-parsing","title":"Step 2: Docstring Parsing","text":"<p>The Tool class parses docstrings to extract metadata:</p> <pre><code>flowchart TD\n    A[Function] --&gt; B[Extract __doc__]\n    B --&gt; C{Docstring format?}\n\n    C --&gt;|Google| D[GoogleDocstringParser]\n    C --&gt;|NumPy| E[NumpyDocstringParser]\n    C --&gt;|reStructuredText| F[RstDocstringParser]\n\n    D --&gt; G[Parse sections]\n    E --&gt; G\n    F --&gt; G\n\n    G --&gt; H[Extract description]\n    G --&gt; I[Extract parameters]\n    G --&gt; J[Extract return info]\n\n    H --&gt; K[FuncMetadata]\n    I --&gt; K\n    J --&gt; K\n</code></pre>"},{"location":"architecture/tool-registration/#supported-docstring-formats","title":"Supported Docstring Formats","text":"<p>Universal-mcp supports multiple docstring styles:</p>"},{"location":"architecture/tool-registration/#google-style","title":"Google Style","text":"<pre><code>def create_issue(title: str, body: str) -&gt; dict:\n    \"\"\"Create a new GitHub issue.\n\n    Args:\n        title: The issue title\n        body: The issue description\n\n    Returns:\n        The created issue data\n    \"\"\"\n</code></pre>"},{"location":"architecture/tool-registration/#numpy-style","title":"NumPy Style","text":"<pre><code>def create_issue(title: str, body: str) -&gt; dict:\n    \"\"\"Create a new GitHub issue.\n\n    Parameters\n    ----------\n    title : str\n        The issue title\n    body : str\n        The issue description\n\n    Returns\n    -------\n    dict\n        The created issue data\n    \"\"\"\n</code></pre>"},{"location":"architecture/tool-registration/#restructuredtext-style","title":"reStructuredText Style","text":"<pre><code>def create_issue(title: str, body: str) -&gt; dict:\n    \"\"\"Create a new GitHub issue.\n\n    :param title: The issue title\n    :param body: The issue description\n    :return: The created issue data\n    \"\"\"\n</code></pre>"},{"location":"architecture/tool-registration/#step-3-type-hint-extraction","title":"Step 3: Type Hint Extraction","text":"<p>Python type hints are used to generate JSON Schema types:</p> <pre><code>flowchart TD\n    A[Type Hints] --&gt; B{Type?}\n\n    B --&gt;|str| C[\"JSON: string\"]\n    B --&gt;|int| D[\"JSON: integer\"]\n    B --&gt;|float| E[\"JSON: number\"]\n    B --&gt;|bool| F[\"JSON: boolean\"]\n    B --&gt;|list| G[\"JSON: array\"]\n    B --&gt;|dict| H[\"JSON: object\"]\n    B --&gt;|Optional/None| I[\"Add to optional fields\"]\n    B --&gt;|Union| J[\"JSON: anyOf\"]\n    B --&gt;|Literal| K[\"JSON: enum\"]\n\n    C --&gt; L[JSON Schema]\n    D --&gt; L\n    E --&gt; L\n    F --&gt; L\n    G --&gt; L\n    H --&gt; L\n    I --&gt; L\n    J --&gt; L\n    K --&gt; L\n</code></pre>"},{"location":"architecture/tool-registration/#type-mapping-examples","title":"Type Mapping Examples","text":"Python Type JSON Schema Type Example <code>str</code> <code>{\"type\": \"string\"}</code> \"hello\" <code>int</code> <code>{\"type\": \"integer\"}</code> 42 <code>float</code> <code>{\"type\": \"number\"}</code> 3.14 <code>bool</code> <code>{\"type\": \"boolean\"}</code> true <code>list[str]</code> <code>{\"type\": \"array\", \"items\": {\"type\": \"string\"}}</code> [\"a\", \"b\"] <code>dict[str, Any]</code> <code>{\"type\": \"object\"}</code> {\"key\": \"value\"} <code>str \\| None</code> <code>{\"type\": \"string\"}</code> (optional) \"hello\" or null <code>Literal[\"a\", \"b\"]</code> <code>{\"type\": \"string\", \"enum\": [\"a\", \"b\"]}</code> \"a\""},{"location":"architecture/tool-registration/#step-4-schema-generation","title":"Step 4: Schema Generation","text":"<p>The complete JSON Schema for a tool is generated:</p> <pre><code>flowchart TD\n    A[Function Metadata] --&gt; B[Create Schema Object]\n\n    C[Name] --&gt; B\n    D[Description] --&gt; B\n    E[Parameters] --&gt; B\n\n    B --&gt; F[JSON Schema]\n\n    F --&gt; G[Tool Definition]\n    G --&gt; H[{&lt;br/&gt;name: string,&lt;br/&gt;description: string,&lt;br/&gt;inputSchema: object&lt;br/&gt;}]\n</code></pre>"},{"location":"architecture/tool-registration/#example-schema","title":"Example Schema","text":"<p>For this function: </p><pre><code>def create_issue(\n    title: str,\n    body: str,\n    labels: list[str] | None = None\n) -&gt; dict:\n    \"\"\"Create a new GitHub issue.\n\n    Args:\n        title: The issue title\n        body: The issue description\n        labels: Optional list of label names\n    \"\"\"\n</code></pre><p></p> <p>Generated schema: </p><pre><code>{\n  \"name\": \"create_issue\",\n  \"description\": \"Create a new GitHub issue\",\n  \"inputSchema\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"title\": {\n        \"type\": \"string\",\n        \"description\": \"The issue title\"\n      },\n      \"body\": {\n        \"type\": \"string\",\n        \"description\": \"The issue description\"\n      },\n      \"labels\": {\n        \"type\": \"array\",\n        \"items\": {\"type\": \"string\"},\n        \"description\": \"Optional list of label names\"\n      }\n    },\n    \"required\": [\"title\", \"body\"]\n  }\n}\n</code></pre><p></p>"},{"location":"architecture/tool-registration/#step-5-tool-registration","title":"Step 5: Tool Registration","text":"<p>Tools are registered in the ToolManager:</p> <pre><code>sequenceDiagram\n    participant Server as BaseServer\n    participant ToolMgr as ToolManager\n    participant Tool as Tool\n\n    Server-&gt;&gt;ToolMgr: add_tool(tool)\n\n    alt Tool name unique\n        ToolMgr-&gt;&gt;ToolMgr: _tools[name] = tool\n        Note over ToolMgr: Tool registered\n        ToolMgr--&gt;&gt;Server: Success\n    else Tool name conflict\n        Note over ToolMgr: Tool with this name&lt;br/&gt;already exists\n        ToolMgr--&gt;&gt;Server: ToolAlreadyExistsError\n    end\n</code></pre>"},{"location":"architecture/tool-registration/#tool-namespacing","title":"Tool Namespacing","text":"<p>If multiple applications have tools with the same name, they can be namespaced:</p> <pre><code># Without namespace (conflict)\ngithub.create_issue()\njira.create_issue()  # Conflict!\n\n# With namespace\ngithub_create_issue()\njira_create_issue()  # Unique names\n</code></pre> <p>Applications can prefix tool names:</p> <pre><code>class GitHubApp(APIApplication):\n    def list_tools(self) -&gt; list[Callable]:\n        tools = [self.create_issue, self.list_issues]\n        # Add namespace prefix\n        for tool in tools:\n            tool.__name__ = f\"github_{tool.__name__}\"\n        return tools\n</code></pre>"},{"location":"architecture/tool-registration/#complete-example","title":"Complete Example","text":"<p>Here's a complete example showing all steps:</p>"},{"location":"architecture/tool-registration/#application-definition","title":"Application Definition","text":"<pre><code>from universal_mcp.applications import APIApplication\nfrom typing import Literal\n\nclass WeatherApp(APIApplication):\n    def list_tools(self):\n        return [self.get_weather]\n\n    def get_weather(\n        self,\n        city: str,\n        units: Literal[\"metric\", \"imperial\"] = \"metric\",\n        include_forecast: bool = False\n    ) -&gt; dict:\n        \"\"\"Get current weather for a city.\n\n        Args:\n            city: City name (e.g., \"London\", \"New York\")\n            units: Temperature units (metric for Celsius, imperial for Fahrenheit)\n            include_forecast: Whether to include 5-day forecast\n\n        Returns:\n            Weather data including temperature, humidity, and conditions\n        \"\"\"\n        # Implementation\n        return self.get(f\"/weather?q={city}&amp;units={units}\")\n</code></pre>"},{"location":"architecture/tool-registration/#generated-tool","title":"Generated Tool","text":"<pre><code>{\n  \"name\": \"get_weather\",\n  \"description\": \"Get current weather for a city\",\n  \"inputSchema\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"city\": {\n        \"type\": \"string\",\n        \"description\": \"City name (e.g., \\\"London\\\", \\\"New York\\\")\"\n      },\n      \"units\": {\n        \"type\": \"string\",\n        \"enum\": [\"metric\", \"imperial\"],\n        \"description\": \"Temperature units (metric for Celsius, imperial for Fahrenheit)\",\n        \"default\": \"metric\"\n      },\n      \"include_forecast\": {\n        \"type\": \"boolean\",\n        \"description\": \"Whether to include 5-day forecast\",\n        \"default\": false\n      }\n    },\n    \"required\": [\"city\"]\n  }\n}\n</code></pre>"},{"location":"architecture/tool-registration/#mcp-tool-definition","title":"MCP Tool Definition","text":"<p>This is exposed to MCP clients as:</p> <pre><code>{\n  \"tools\": [\n    {\n      \"name\": \"get_weather\",\n      \"description\": \"Get current weather for a city\",\n      \"inputSchema\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"city\": {\n            \"type\": \"string\",\n            \"description\": \"City name (e.g., \\\"London\\\", \\\"New York\\\")\"\n          },\n          \"units\": {\n            \"type\": \"string\",\n            \"enum\": [\"metric\", \"imperial\"],\n            \"default\": \"metric\"\n          },\n          \"include_forecast\": {\n            \"type\": \"boolean\",\n            \"default\": false\n          }\n        },\n        \"required\": [\"city\"]\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"architecture/tool-registration/#best-practices","title":"Best Practices","text":""},{"location":"architecture/tool-registration/#1-write-clear-docstrings","title":"1. Write Clear Docstrings","text":"<pre><code># Good\ndef create_issue(title: str, body: str) -&gt; dict:\n    \"\"\"Create a new GitHub issue.\n\n    Args:\n        title: The issue title (max 256 characters)\n        body: The issue description (supports Markdown)\n\n    Returns:\n        Created issue data with number and URL\n    \"\"\"\n\n# Bad\ndef create_issue(title: str, body: str) -&gt; dict:\n    \"\"\"Creates issue.\"\"\"  # Too brief, no parameter docs\n</code></pre>"},{"location":"architecture/tool-registration/#2-use-type-hints","title":"2. Use Type Hints","text":"<pre><code># Good\ndef search_repos(\n    query: str,\n    language: str | None = None,\n    max_results: int = 10\n) -&gt; list[dict]:\n\n# Bad\ndef search_repos(query, language=None, max_results=10):\n    # No type hints means no schema validation\n</code></pre>"},{"location":"architecture/tool-registration/#3-use-literal-for-enums","title":"3. Use Literal for Enums","text":"<pre><code># Good - generates enum in schema\nfrom typing import Literal\n\ndef set_priority(\n    issue_id: int,\n    priority: Literal[\"low\", \"medium\", \"high\", \"critical\"]\n) -&gt; dict:\n\n# Bad - any string accepted\ndef set_priority(issue_id: int, priority: str) -&gt; dict:\n</code></pre>"},{"location":"architecture/tool-registration/#4-document-return-types","title":"4. Document Return Types","text":"<pre><code># Good\ndef get_user(username: str) -&gt; dict:\n    \"\"\"Fetch user profile.\n\n    Returns:\n        dict: User data containing:\n            - id (int): User ID\n            - username (str): Username\n            - email (str): Email address\n    \"\"\"\n\n# Bad\ndef get_user(username: str) -&gt; dict:\n    \"\"\"Fetch user profile.\"\"\"\n    # No info about return structure\n</code></pre>"},{"location":"architecture/tool-registration/#debugging-tool-registration","title":"Debugging Tool Registration","text":"<p>If tools aren't appearing:</p> <ol> <li> <p>Check list_tools() returns callables </p><pre><code>tools = app.list_tools()\nassert all(callable(t) for t in tools)\n</code></pre><p></p> </li> <li> <p>Verify docstrings exist </p><pre><code>for tool in tools:\n    assert tool.__doc__ is not None\n</code></pre><p></p> </li> <li> <p>Check type hints </p><pre><code>import inspect\nsig = inspect.signature(tool)\nfor param in sig.parameters.values():\n    assert param.annotation != inspect.Parameter.empty\n</code></pre><p></p> </li> <li> <p>Enable debug logging </p><pre><code>import logging\nlogging.getLogger(\"universal_mcp\").setLevel(logging.DEBUG)\n</code></pre><p></p> </li> </ol>"},{"location":"architecture/tool-registration/#related-documentation","title":"Related Documentation","text":"<ul> <li>Class Hierarchy - Tool and ToolManager classes</li> <li>Request Flow - How tools are invoked</li> <li>Tools API - Tool class reference</li> </ul>"}]}