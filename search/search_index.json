{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Universal MCP","text":"<p>Universal MCP acts as a middleware layer for your API applications, enabling seamless integration with various services through the Model Control Protocol (MCP). It simplifies credential management, authorization, dynamic app enablement, and provides a robust framework for building and managing AI-powered tools.</p>"},{"location":"#features","title":"\ud83c\udf1f Features","text":"<ul> <li>MCP (Model Control Protocol) Integration: Seamlessly works with MCP server architecture for standardized agent-tool communication.</li> <li>Simplified API Integration: Connect to services like GitHub, Google Calendar, Gmail, Reddit, Tavily, and more with minimal code. See AgentR for a list of available applications.</li> <li>Managed Authentication: Built-in support for API keys and OAuth-based authentication flows, often managed via the AgentR platform.</li> <li>Extensible Architecture: Easily build and add new app integrations with minimal boilerplate using provided base classes and generation tools.</li> <li>Credential Management: Flexible and secure storage options for API credentials (memory, environment variables, system keyring).</li> <li>Comprehensive Tool Management: Robust tool registration, Pydantic-based validation, automatic docstring parsing, and execution capabilities. Supports conversion between MCP, LangChain, and OpenAI tool formats.</li> <li>Multiple Server Types: Configurations for local development, AgentR-connected dynamic app loading, and single-application servers.</li> <li>Playground Environment: Includes an interactive Streamlit-based playground for testing agents and tools.</li> </ul>"},{"location":"#installation","title":"\ud83d\udd27 Installation","text":"<p>Install Universal MCP using pip:</p> <pre><code>pip install universal-mcp\n</code></pre>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>Important Prerequisite: AgentR API Key (If Using AgentR Integration)</p> <p>If you plan to use integrations with <code>type: \"agentr\"</code> (for services like GitHub, Gmail, Notion via the AgentR platform), or if you run the MCP server itself with <code>type: \"agentr\"</code>, you first need an AgentR API key:</p> <ol> <li>Visit https://agentr.dev to create an account and generate an API key from your dashboard.</li> <li>Set it as an environment variable before running the MCP server:     <pre><code>export AGENTR_API_KEY=\"your_api_key_here\"\n</code></pre></li> </ol> <p>1. Create a Configuration File (e.g., <code>config.json</code>)</p> <p>This file defines the server settings, credential stores, and the applications to load with their respective integrations.</p> <pre><code>{\n  \"name\": \"My Local MCP Server\",\n  \"description\": \"A server for testing applications locally\",\n  \"type\": \"local\", // \"local\" or \"agentr\"\n  \"transport\": \"sse\", // \"sse\", \"stdio\", or \"http\"\n  \"port\": 8005, // Relevant for \"sse\" or \"http\"\n  \"store\": {\n    // Default store for integrations\n    \"name\": \"my_mcp_store\",\n    \"type\": \"keyring\" // \"keyring\", \"environment\", or \"memory\"\n  },\n  \"apps\": [\n    {\n      \"name\": \"zenquotes\", // App slug (e.g., from agentr.dev)\n      \"integration\": null // No authentication needed for this app\n    },\n    {\n      \"name\": \"tavily\",\n      \"integration\": {\n        \"name\": \"TAVILY_API_KEY\", // Unique name for this credential if type is \"api_key\"\n        \"type\": \"api_key\",\n        \"store\": {\n          // Override default store for this specific app\n          \"type\": \"environment\" // Looks for TAVILY_API_KEY env var\n        }\n      }\n    },\n    {\n      \"name\": \"github\",\n      \"integration\": {\n        \"name\": \"github\", // Matches the service name in AgentR\n        \"type\": \"agentr\" // Uses AgentR platform for auth/creds\n      }\n    }\n  ]\n}\n</code></pre> <p>Notes on <code>config.json</code>:</p> <ul> <li><code>type: \"local\"</code>: Runs applications defined directly in the config's <code>apps</code> list.</li> <li><code>type: \"agentr\"</code>: Connects to the AgentR platform to dynamically load user-enabled apps (ignores the <code>apps</code> list in the config) and handle credentials. Requires <code>AGENTR_API_KEY</code> environment variable.</li> <li><code>store</code>: Defines credential storage.</li> <li><code>environment</code>: Looks for an environment variable named <code>&lt;INTEGRATION_NAME_UPPERCASE&gt;</code> (e.g., <code>TAVILY_API_KEY</code> for the example above).</li> <li><code>keyring</code>: Uses the system's secure credential storage.</li> <li><code>memory</code>: Transient storage, lost when the server stops.</li> <li><code>integration</code>: Configures authentication for each app.</li> <li><code>type: \"agentr\"</code>: Uses the AgentR platform for OAuth/credential management.</li> <li><code>type: \"api_key\"</code>: Uses the specified <code>store</code> to retrieve the key.</li> </ul> <p>2. Run the Server via CLI</p> <p>Ensure any required environment variables (like <code>TAVILY_API_KEY</code> for the Tavily example, or <code>AGENTR_API_KEY</code> if using <code>\"agentr\"</code> type server/integrations) are set.</p> <pre><code>universal_mcp run -c config.json\n</code></pre> <p>The server will start, load the configured applications (or connect to AgentR if <code>type: \"agentr\"</code>), and listen for connections based on the <code>transport</code> type.</p>"},{"location":"#using-the-playground","title":"\ud83d\udee0\ufe0f Using the Playground","text":"<p>The <code>playground</code> directory provides a runnable Streamlit application for interacting with agents that can use tools from an MCP server.</p> <p>Prerequisites:</p> <ul> <li><code>local_config.json</code>: This file must exist in the project root directory (the same directory as this <code>README.md</code>). It configures the local MCP server that the playground's agent can connect to if you choose to run one. For an example, see the <code>local_config.json</code> structure in the Playground README.</li> <li>Dependencies: Install playground-specific dependencies. If you have the project cloned, you might install them via:   <pre><code>pip install -e .[playground]\n# or manually install fastapi, streamlit, uvicorn, langchain-openai, etc.\n</code></pre></li> </ul> <p>Running the Playground:</p> <p>The easiest way is to use the automated startup script from the project root directory:</p> <pre><code>python playground\n</code></pre> <p>This script will:</p> <ol> <li>Optionally start a local MCP server (based on your <code>local_config.json</code>) if you confirm.</li> <li>Launch the Streamlit application.</li> </ol> <p>For more detailed setup, manual startup instructions, and an explanation of the <code>local_config.json</code> for the playground, please refer to the Playground README.</p>"},{"location":"#available-applications","title":"\ud83e\udde9 Available Applications","text":"<p>Universal MCP can integrate with a wide variety of applications. For a list of publicly available applications and their slugs (e.g., \"github\", \"google-calendar\"), please visit AgentR Applications. Applications are typically installed dynamically by Universal MCP from their respective repositories when first referenced by slug.</p> <p>Authentication Type Notes:</p> <ul> <li>OAuth (via AgentR): Usually requires configuring the app's integration with <code>type: \"agentr\"</code> in your <code>ServerConfig</code>. This leverages the AgentR platform for the OAuth flow and requires the <code>AGENTR_API_KEY</code> to be set.</li> <li>API Key (via Integration): Requires configuring <code>type: \"api_key\"</code> for the app's integration in your <code>ServerConfig</code>, along with a <code>store</code> (like <code>environment</code> or <code>keyring</code>) to specify where the API key is located.</li> </ul>"},{"location":"#integration-types","title":"\ud83d\udd10 Integration Types","text":"<p>Universal MCP supports different ways to handle authentication for applications:</p>"},{"location":"#1-api-key-integration-type-api_key","title":"1. API Key Integration (<code>type: \"api_key\"</code>)","text":"<p>For services that authenticate via simple API keys.</p> <pre><code>// In your ServerConfig apps array:\n{\n  \"name\": \"tavily\",\n  \"integration\": {\n    \"name\": \"TAVILY_API_KEY\", // Used by the store (e.g., as env var name)\n    \"type\": \"api_key\",\n    \"store\": {\n      \"type\": \"environment\" // Or \"keyring\", \"memory\"\n    }\n  }\n}\n</code></pre>"},{"location":"#2-agentr-integration-type-agentr","title":"2. AgentR Integration (<code>type: \"agentr\"</code>)","text":"<p>Recommended for services integrated with the AgentR platform, which typically handles OAuth flows or centrally managed credentials. Requires the <code>AGENTR_API_KEY</code> environment variable to be set for the MCP server process.</p> <pre><code>// In your ServerConfig apps array:\n{\n  \"name\": \"github\",\n  \"integration\": {\n    \"name\": \"github\", // Matches the service name configured in AgentR\n    \"type\": \"agentr\"\n  }\n}\n</code></pre> <p>When an action requiring authorization is called, the <code>AgentRIntegration</code> will prompt the user (via the MCP client) to visit a URL to complete the OAuth flow managed by AgentR. This is also the default integration type for apps if the main server config is <code>type: \"agentr\"</code>.</p>"},{"location":"#3-direct-oauth-integration-type-oauth","title":"3. Direct OAuth Integration (<code>type: \"oauth\"</code>)","text":"<p>While <code>AgentRIntegration</code> is generally preferred for OAuth, a direct <code>OAuthIntegration</code> class exists. However, it requires manual configuration of client IDs, secrets, and callback handling, which is more complex to set up outside the AgentR platform.</p>"},{"location":"#cli-usage","title":"\ud83e\udd16 CLI Usage","text":"<p>Universal MCP includes a powerful command-line interface:</p> <pre><code># Run the MCP server using a configuration file\nuniversal_mcp run -c config.json\n\n# Initialize a new MCP application project structure\nuniversal_mcp init --app-name my-cool-app --o ./my-apps --integration-type api_key\n\n# Generate API client code and application structure from an OpenAPI schema\nuniversal_mcp generate -s &lt;path_to_schema.json_or_yaml&gt; -o &lt;path/to/app_output_directory&gt; --c CustomAppClassName\n# Example: universal_mcp generate -s notion_api.yaml -o ./custom_apps/notion --c MyNotionApp\n\n# Preprocess an OpenAPI schema using an LLM to fill/enhance descriptions\nuniversal_mcp preprocess -s &lt;path_to_input_schema.json_or_yaml&gt; -o &lt;path_to_processed_schema.json_or_yaml&gt;\n\n# Generate Google-style docstrings for functions in a Python file using an LLM\nuniversal_mcp docgen &lt;path/to/app_file.py&gt;\n\n# Generate a README.md for a generated application file\nuniversal_mcp readme &lt;path/to/app_file.py&gt;\n\n# Install MCP configuration for supported desktop apps (e.g., Claude, Cursor)\n# Requires an AgentR API key for configuration.\nuniversal_mcp install claude\nuniversal_mcp install cursor\n\n# Check installed version (standard typer command)\nuniversal_mcp --version\n</code></pre>"},{"location":"#requirements","title":"\ud83d\udccb Requirements","text":"<ul> <li>Python 3.10+</li> <li>Key Dependencies (installed automatically via pip, see <code>pyproject.toml</code> for full list):</li> <li><code>mcp-server</code></li> <li><code>loguru</code></li> <li><code>typer</code></li> <li><code>httpx</code></li> <li><code>pydantic</code></li> <li><code>pyyaml</code></li> <li><code>keyring</code> (for <code>KeyringStore</code>)</li> <li><code>litellm</code> (for <code>docgen</code> and <code>preprocess</code> commands)</li> <li><code>uv</code> (used internally for dynamic package installation)</li> </ul>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<p>For more detailed information about specific components:</p> <ul> <li>Applications Framework</li> <li>Tool Management</li> <li>Server Implementations</li> <li>Credential Stores</li> <li>Integration &amp; Authentication</li> <li>Playground Usage</li> </ul>"},{"location":"#license","title":"\ud83d\udcdd License","text":"<p>This project is licensed under the MIT License. See the LICENSE file for details.</p>"},{"location":"applications/","title":"Universal MCP Applications Module","text":"<p>This module provides the core functionality for managing and integrating applications within the Universal MCP system. It offers a flexible framework for creating, managing, and interacting with various types of applications through a unified interface.</p>"},{"location":"applications/#overview","title":"Overview","text":"<p>The applications module provides three main base classes for building application integrations:</p> <ol> <li><code>BaseApplication</code>: The abstract base class that defines the common interface for all applications</li> <li><code>APIApplication</code>: A concrete implementation for applications that communicate via HTTP APIs</li> <li><code>GraphQLApplication</code>: A specialized implementation for applications that use GraphQL APIs</li> </ol>"},{"location":"applications/#key-features","title":"Key Features","text":"<ul> <li>Dynamic Application Loading: Applications can be loaded dynamically from external packages</li> <li>Unified Credential Management: Centralized handling of application credentials</li> <li>HTTP API Support: Built-in support for RESTful API interactions</li> <li>GraphQL Support: Specialized support for GraphQL-based applications</li> <li>Automatic Package Installation: Automatic installation of application packages from GitHub</li> </ul>"},{"location":"applications/#base-classes","title":"Base Classes","text":""},{"location":"applications/#baseapplication","title":"BaseApplication","text":"<p>The foundation class for all applications, providing: - Basic initialization - Credential management - Tool listing interface</p>"},{"location":"applications/#apiapplication","title":"APIApplication","text":"<p>Extends BaseApplication to provide: - HTTP client management - Authentication handling - Common HTTP methods (GET, POST, PUT, DELETE, PATCH) - Request/response handling</p>"},{"location":"applications/#graphqlapplication","title":"GraphQLApplication","text":"<p>Specialized for GraphQL-based applications, offering: - GraphQL client management - Query and mutation execution - Authentication handling</p>"},{"location":"applications/#usage","title":"Usage","text":""},{"location":"applications/#creating-a-new-application","title":"Creating a New Application","text":"<ol> <li>Create a new package following the naming convention: <code>universal_mcp_&lt;app_name&gt;</code></li> <li>Implement your application class inheriting from one of the base classes</li> <li>Name your class following the convention: <code>&lt;AppName&gt;App</code></li> </ol> <p>Example: <pre><code>from universal_mcp.applications import APIApplication\n\nclass MyApp(APIApplication):\n    def __init__(self, name: str, integration=None, **kwargs):\n        super().__init__(name, integration, **kwargs)\n        self.base_url = \"https://api.example.com\"\n\n    def list_tools(self):\n        return [self.my_tool]\n\n    def my_tool(self):\n        # Implementation here\n        pass\n</code></pre></p>"},{"location":"applications/#loading-an-application","title":"Loading an Application","text":"<pre><code>from universal_mcp.applications import app_from_config\nfrom universal_mcp.config import AppConfig\n\napp_config_pkg = AppConfig(name=\"my-app\")\nMyAppFromPackage = app_from_config(app_config_pkg)\napp_pkg_instance = MyAppFromPackage()\n</code></pre>"},{"location":"applications/#authentication","title":"Authentication","text":"<p>The module supports various authentication methods: - API Keys - Access Tokens - Custom Headers - Bearer Tokens</p> <p>Credentials are managed through the integration system and can be accessed via the <code>credentials</code> property.</p>"},{"location":"applications/#error-handling","title":"Error Handling","text":"<p>The module includes comprehensive error handling for: - Package installation failures - Import errors - API request failures - Authentication issues</p>"},{"location":"applications/#logging","title":"Logging","text":"<p>All operations are logged using the <code>loguru</code> logger, providing detailed information about: - Application initialization - API requests - Authentication attempts - Package installation - Error conditions</p>"},{"location":"applications/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8+</li> <li>httpx</li> <li>gql</li> <li>loguru</li> <li>uv (for package installation)</li> </ul>"},{"location":"applications/#contributing","title":"Contributing","text":"<p>To contribute a new application: 1. Create a new package following the naming conventions 2. Implement the application class 3. Add proper error handling and logging 4. Include comprehensive documentation 5. Submit a pull request to the Universal MCP repository</p>"},{"location":"integrations/","title":"Integrations","text":"<p>This package provides integration classes for handling authentication and authorization with external services.</p>"},{"location":"integrations/#overview","title":"Overview","text":"<p>An Integration defines how an application authenticates and authorizes with a service provider. The base <code>Integration</code> class provides an interface that all integrations must implement.</p>"},{"location":"integrations/#supported-integrations","title":"Supported Integrations","text":""},{"location":"integrations/#agentr-integration","title":"AgentR Integration","text":"<p>The <code>AgentRIntegration</code> class handles OAuth-based authentication flow with the AgentR API. It requires an API key which can be obtained from agentr.dev.</p>"},{"location":"integrations/#api-key-integration","title":"API Key Integration","text":"<p>The <code>ApiKeyIntegration</code> class provides a simple API key based authentication mechanism. API keys are configured via environment variables.</p>"},{"location":"integrations/#usage","title":"Usage","text":"<p>Each integration implements three key methods:</p> <ul> <li><code>authorize()</code> - Initiates the authorization flow</li> <li><code>get_credentials()</code> - Retrieves stored credentials</li> <li><code>set_credentials()</code> - Stores new credentials</li> </ul> <p>See the individual integration classes for specific usage details.</p>"},{"location":"playground/","title":"Universal MCP Playground","text":"<p>The Playground provides an interactive environment to test and demonstrate the capabilities of agents built with LangGraph that utilize tools exposed via the Universal MCP (Model Control Protocol). It features a Streamlit-based chat interface allowing users to interact with an AI agent that can leverage tools from a connected MCP server.</p>"},{"location":"playground/#prerequisites","title":"\ud83d\udccb Prerequisites","text":"<p>Before running the playground, ensure you have the following:</p> <ol> <li>Python Environment: Python 3.11+ is recommended.</li> <li> <p>Dependencies: Install the necessary dependencies. If you have the project cloned, you can often install them using:</p> <pre><code>pip install -e .[playground]\n</code></pre> <p>Alternatively, manually install <code>streamlit</code>, <code>langchain-openai</code>, <code>langgraph</code>, <code>langchain-mcp-adapters</code>, <code>loguru</code>, <code>pydantic</code>, etc.</p> </li> <li> <p>LLM API Access (Azure OpenAI by default):     The default agent in <code>playground/agents/react.py</code> uses <code>AzureChatOpenAI</code>. You'll need to set the following environment variables:</p> <ul> <li><code>AZURE_OPENAI_API_KEY</code>: Your Azure OpenAI API key.</li> <li><code>AZURE_OPENAI_ENDPOINT</code>: Your Azure OpenAI endpoint URL.   If you wish to use a different LLM, you'll need to modify <code>playground/agents/react.py</code>.</li> </ul> </li> <li> <p>AgentR API Key (for Auto Agent):     If you want to use the Auto Agent, you'll need to set the following environment variable:</p> <ul> <li><code>AUTO_AGENT_API_KEY</code>: Your AgentR API key (get it from agentr.dev)</li> </ul> </li> <li> <p><code>local_config.json</code> in Project Root:     This file is crucial. It configures the local Universal MCP server that the playground's agent will connect to for tools. This file must be placed in the root directory of the <code>universal-mcp</code> project (i.e., one level above the <code>src</code> directory).</p> <p>The agent in <code>playground/agents/react.py</code> expects to connect to an MCP server at <code>http://localhost:8005</code> using Server-Sent Events (SSE). Therefore, your <code>local_config.json</code> should reflect this:</p> <p>Example <code>local_config.json</code> (place in project root):</p> <pre><code>{\n  \"name\": \"Playground Local MCP Server\",\n  \"description\": \"MCP server for playground agent tools\",\n  \"type\": \"local\",\n  \"transport\": \"sse\", // Must be \"sse\" for the playground agent\n  \"port\": 8005, // Must be 8005 for the playground agent\n  \"apps\": [\n    {\n      \"name\": \"zenquotes\" // Example: Exposes the zenquotes app and its tools\n    },\n    {\n      \"name\": \"tavily\", // Example: Exposes Tavily search\n      \"integration\": {\n        \"name\": \"TAVILY_API_KEY\", // Credential name\n        \"type\": \"api_key\",\n        \"store\": {\n          \"type\": \"environment\" // Expects TAVILY_API_KEY env var\n        }\n      }\n    }\n    // Add other apps you want the agent to access\n  ]\n}\n</code></pre> <ul> <li>Ensure the <code>transport</code> is <code>\"sse\"</code> and <code>port</code> is <code>8005</code>.</li> <li>Add any applications (tools) you want the agent to be able to use in the <code>apps</code> array. Ensure any necessary API keys for these tools are set as environment variables if their integration is configured to use <code>type: \"environment\"</code>.</li> </ul> </li> </ol>"},{"location":"playground/#agent-types","title":"\ud83e\udd16 Agent Types","text":"<p>The playground supports two different agent types:</p>"},{"location":"playground/#react-agent-default","title":"React Agent (Default)","text":"<p>The traditional MCP-based agent that connects to MCP servers and uses tools via the Model Control Protocol. This agent works with the local MCP server configuration.</p>"},{"location":"playground/#auto-agent","title":"Auto Agent","text":"<p>An intelligent agent that can: - Decompose complex tasks into individual steps - Automatically search for and select relevant apps for each task - Choose appropriate actions from those apps - Execute tasks in sequence with context passing between steps</p> <p>To use the Auto Agent, you'll need to set the <code>AUTO_AGENT_API_KEY</code> environment variable.</p>"},{"location":"playground/#running-the-playground","title":"\u25b6\ufe0f Running the Playground","text":""},{"location":"playground/#automated-startup-recommended","title":"Automated Startup (Recommended)","text":"<p>The easiest way to start all necessary services is using the provided Python startup script. Execute this command from the root directory of the <code>universal-mcp</code> project:</p> <pre><code>python playground\n</code></pre> <p>This script will:</p> <ol> <li>Prompt you if you want to run a local MCP server (using <code>local_config.json</code>). If you say yes, it starts the MCP server.</li> <li>Launch the Streamlit application.</li> </ol> <p>Your default web browser should open to the Streamlit app.</p>"},{"location":"playground/#manual-startup-alternative","title":"Manual Startup (Alternative)","text":"<p>If you prefer, or if the automated script doesn't suit your needs, you can start the components manually. Run each command from the project root directory in a separate terminal window:</p> <ol> <li> <p>Terminal 1: Start the Universal MCP Server (Ensures the agent has tools to connect to. Uses <code>local_config.json</code> from the project root.)</p> <pre><code>universal_mcp run -c local_config.json\n</code></pre> <p>Wait for the server to indicate it's running (e.g., \"MCP SSE Server running on http://localhost:8005\").</p> </li> <li> <p>Terminal 2: Start the Streamlit Application <pre><code>python -m streamlit run playground/streamlit.py\n</code></pre> This will typically open the Streamlit app in your default web browser.</p> </li> </ol>"},{"location":"playground/#x-stopping-the-services","title":"X Stopping the Services","text":"<ul> <li> <p>Automated Startup: Press <code>Ctrl + C</code> in the terminal where you ran <code>python playground</code>. This should terminate both the Streamlit app and the MCP server (if started by the script).</p> </li> <li> <p>Manual Startup: Go to each terminal window where you started a service (MCP server, Streamlit app) and press <code>Ctrl + C</code>.</p> </li> </ul>"},{"location":"servers/","title":"Servers","text":"<p>This package provides server implementations for hosting and managing MCP (Model Control Protocol) applications.</p>"},{"location":"servers/#overview","title":"Overview","text":"<p>The server implementations provide different ways to host and expose MCP applications and their tools. The base <code>BaseServer</code> class provides common functionality that all server implementations inherit.</p>"},{"location":"servers/#supported-server-types","title":"Supported Server Types","text":""},{"location":"servers/#local-server","title":"Local Server","text":"<p>The <code>LocalServer</code> class provides a local development server implementation that: - Loads applications from local configuration - Manages a local store for data persistence - Supports integration with external services - Exposes application tools through the MCP protocol</p>"},{"location":"servers/#agentr-server","title":"AgentR Server","text":"<p>The <code>AgentRServer</code> class provides a server implementation that: - Connects to the AgentR API - Dynamically fetches and loads available applications - Manages AgentR-specific integrations - Requires an API key for authentication</p>"},{"location":"servers/#single-mcp-server","title":"Single MCP Server","text":"<p>The <code>SingleMCPServer</code> class provides a minimal server implementation that: - Hosts a single application instance - Ideal for development and testing - Does not manage integrations or stores internally - Exposes only the tools from the provided application</p>"},{"location":"servers/#core-features","title":"Core Features","text":"<p>All server implementations provide:</p> <ul> <li>Tool management and registration</li> <li>Application loading and configuration</li> <li>Error handling and logging</li> <li>MCP protocol compliance</li> <li>Integration support</li> </ul>"},{"location":"servers/#usage","title":"Usage","text":"<p>Each server implementation can be initialized with a <code>ServerConfig</code> object that specifies: - Server name and description - Port configuration - Application configurations - Store configuration (where applicable)</p> <p>Example: <pre><code>from universal_mcp.servers import LocalServer\nfrom universal_mcp.config import ServerConfig\n\nconfig = ServerConfig(\n    name=\"My Local Server\",\n    description=\"Development server for testing applications\",\n    port=8000,\n    # ... additional configuration\n)\n\nserver = LocalServer(config)\n</code></pre></p>"},{"location":"servers/#tool-management","title":"Tool Management","text":"<p>Servers provide methods for: - Adding individual tools - Listing available tools - Calling tools with proper error handling - Formatting tool results</p>"},{"location":"servers/#error-handling","title":"Error Handling","text":"<p>All servers implement comprehensive error handling for: - Tool execution failures - Application loading errors - Integration setup issues - API communication problems</p>"},{"location":"stores/","title":"Universal MCP Stores","text":"<p>The stores module provides a flexible and secure way to manage credentials and sensitive data across different storage backends. It implements a common interface for storing, retrieving, and deleting sensitive information.</p>"},{"location":"stores/#features","title":"Features","text":"<ul> <li>Abstract base class defining a consistent interface for credential stores</li> <li>Multiple storage backend implementations:</li> <li>In-memory store (temporary storage)</li> <li>Environment variable store</li> <li>System keyring store (secure credential storage)</li> <li>Exception handling for common error cases</li> <li>Type hints and comprehensive documentation</li> </ul>"},{"location":"stores/#available-store-implementations","title":"Available Store Implementations","text":""},{"location":"stores/#memorystore","title":"MemoryStore","text":"<p>A simple in-memory store that persists data only for the duration of program execution. Useful for testing or temporary storage.</p> <pre><code>from universal_mcp.stores import MemoryStore\n\nstore = MemoryStore()\nstore.set(\"api_key\", \"secret123\")\nvalue = store.get(\"api_key\")  # Returns \"secret123\"\n</code></pre>"},{"location":"stores/#environmentstore","title":"EnvironmentStore","text":"<p>Uses environment variables to store and retrieve credentials. Useful for containerized environments or CI/CD pipelines.</p> <pre><code>from universal_mcp.stores import EnvironmentStore\n\nstore = EnvironmentStore()\nstore.set(\"API_KEY\", \"secret123\")\nvalue = store.get(\"API_KEY\")  # Returns \"secret123\"\n</code></pre>"},{"location":"stores/#keyringstore","title":"KeyringStore","text":"<p>Leverages the system's secure credential storage facility. Provides the most secure option for storing sensitive data.</p> <pre><code>from universal_mcp.stores import KeyringStore\n\nstore = KeyringStore(app_name=\"my_app\")\nstore.set(\"api_key\", \"secret123\")\nvalue = store.get(\"api_key\")  # Returns \"secret123\"\n</code></pre>"},{"location":"stores/#error-handling","title":"Error Handling","text":"<p>The module provides specific exception types for handling errors:</p> <ul> <li><code>StoreError</code>: Base exception for all store-related errors</li> <li><code>KeyNotFoundError</code>: Raised when a requested key is not found in the store</li> </ul>"},{"location":"stores/#best-practices","title":"Best Practices","text":"<ol> <li>Use <code>KeyringStore</code> for production environments where security is a priority</li> <li>Use <code>EnvironmentStore</code> for containerized or cloud environments</li> <li>Use <code>MemoryStore</code> for testing or temporary storage only</li> <li>Always handle <code>StoreError</code> and <code>KeyNotFoundError</code> exceptions appropriately</li> </ol>"},{"location":"stores/#dependencies","title":"Dependencies","text":"<ul> <li><code>keyring</code>: Required for the KeyringStore implementation</li> <li><code>loguru</code>: Used for logging operations in the KeyringStore</li> </ul>"},{"location":"stores/#contributing","title":"Contributing","text":"<p>New store implementations should inherit from <code>BaseStore</code> and implement all required abstract methods: - <code>get(key: str) -&gt; Any</code> - <code>set(key: str, value: str) -&gt; None</code> - <code>delete(key: str) -&gt; None</code></p>"},{"location":"tools_framework/","title":"Universal MCP Tools","text":"<p>This directory contains the core tooling infrastructure for Universal MCP, providing a flexible and extensible framework for defining, managing, and converting tools across different formats.</p>"},{"location":"tools_framework/#components","title":"Components","text":""},{"location":"tools_framework/#toolspy","title":"<code>tools.py</code>","text":"<p>The main module containing the core tool management functionality:</p> <ul> <li><code>Tool</code> class: Represents a tool with metadata, validation, and execution capabilities</li> <li><code>ToolManager</code> class: Manages tool registration, lookup, and execution</li> <li>Conversion utilities for different tool formats (OpenAI, LangChain, MCP)</li> </ul>"},{"location":"tools_framework/#adapterspy","title":"<code>adapters.py</code>","text":"<p>Contains adapters for converting tools between different formats: - <code>convert_tool_to_mcp_tool</code>: Converts a tool to MCP format - <code>convert_tool_to_langchain_tool</code>: Converts a tool to LangChain format</p>"},{"location":"tools_framework/#func_metadatapy","title":"<code>func_metadata.py</code>","text":"<p>Provides function metadata and argument validation: - <code>FuncMetadata</code> class: Handles function signature analysis and argument validation - <code>ArgModelBase</code> class: Base model for function arguments - Utilities for parsing and validating function signatures</p>"},{"location":"tools_framework/#usage","title":"Usage","text":""},{"location":"tools_framework/#creating-a-tool","title":"Creating a Tool","text":"<pre><code>from universal_mcp.tools import Tool\n\ndef my_tool(param1: str, param2: int) -&gt; str:\n    \"\"\"A simple tool that does something.\n\n    Args:\n        param1: Description of param1\n        param2: Description of param2\n\n    Returns:\n        Description of return value\n    \"\"\"\n    return f\"Result: {param1} {param2}\"\n\ntool = Tool.from_function(my_tool)\n</code></pre>"},{"location":"tools_framework/#managing-tools","title":"Managing Tools","text":"<pre><code>from universal_mcp.tools import ToolManager\n\nmanager = ToolManager()\nmanager.add_tool(my_tool)\n\n# Get a tool by name\ntool = manager.get_tool(\"my_tool\")\n\n# List all tools in a specific format\ntools = manager.list_tools(format=\"openai\")  # or \"langchain\" or \"mcp\"\n</code></pre>"},{"location":"tools_framework/#converting-tools","title":"Converting Tools","text":"<pre><code>from universal_mcp.tools import convert_tool_to_langchain_tool\n\nlangchain_tool = convert_tool_to_langchain_tool(tool)\n</code></pre>"},{"location":"tools_framework/#features","title":"Features","text":"<ul> <li>Automatic docstring parsing for tool metadata</li> <li>Type validation using Pydantic</li> <li>Support for both sync and async tools</li> <li>JSON schema generation for tool parameters</li> <li>Error handling and analytics tracking</li> <li>Tag-based tool organization</li> <li>Multiple format support (OpenAI, LangChain, MCP)</li> </ul>"},{"location":"tools_framework/#best-practices","title":"Best Practices","text":"<ol> <li>Always provide clear docstrings for your tools</li> <li>Use type hints for better validation</li> <li>Handle errors appropriately in your tool implementations</li> <li>Use tags to organize related tools</li> <li>Consider async implementations for I/O-bound operations</li> </ol>"}]}